"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const cli_1 = require("@yarnpkg/cli");
const core_1 = require("@yarnpkg/core");
const core_2 = require("@yarnpkg/core");
const core_3 = require("@yarnpkg/core");
const clipanion_1 = require("clipanion");
const enquirer_1 = require("enquirer");
const suggestUtils = tslib_1.__importStar(require("../suggestUtils"));
// eslint-disable-next-line arca/no-default-export
class AddCommand extends cli_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.packages = [];
        this.json = false;
        this.exact = false;
        this.tilde = false;
        this.caret = false;
        this.dev = false;
        this.peer = false;
        this.optional = false;
        this.preferDev = false;
        this.interactive = null;
        this.cached = false;
    }
    async execute() {
        var _a;
        const configuration = await core_1.Configuration.find(this.context.cwd, this.context.plugins);
        const { project, workspace } = await core_2.Project.find(configuration, this.context.cwd);
        const cache = await core_1.Cache.find(configuration);
        if (!workspace)
            throw new cli_1.WorkspaceRequiredError(project.cwd, this.context.cwd);
        await project.restoreInstallState({
            restoreResolutions: false,
        });
        const interactive = (_a = this.interactive) !== null && _a !== void 0 ? _a : configuration.get(`preferInteractive`);
        const modifier = suggestUtils.getModifier(this, project);
        const strategies = [
            ...interactive ? [
                suggestUtils.Strategy.REUSE,
            ] : [],
            suggestUtils.Strategy.PROJECT,
            ...this.cached ? [
                suggestUtils.Strategy.CACHE,
            ] : [],
            suggestUtils.Strategy.LATEST,
        ];
        const maxResults = interactive
            ? Infinity
            : 1;
        const allSuggestions = await Promise.all(this.packages.map(async (pseudoDescriptor) => {
            const request = pseudoDescriptor.match(/^\.{0,2}\//)
                ? await suggestUtils.extractDescriptorFromPath(pseudoDescriptor, { cwd: this.context.cwd, workspace })
                : core_3.structUtils.parseDescriptor(pseudoDescriptor);
            const target = suggestTarget(workspace, request, {
                dev: this.dev,
                peer: this.peer,
                preferDev: this.preferDev,
                optional: this.optional,
            });
            const suggestions = await suggestUtils.getSuggestedDescriptors(request, { project, workspace, cache, target, modifier, strategies, maxResults });
            return [request, suggestions, target];
        }));
        const checkReport = await core_1.LightReport.start({
            configuration,
            stdout: this.context.stdout,
            suggestInstall: false,
        }, async (report) => {
            for (const [request, { suggestions, rejections }] of allSuggestions) {
                const nonNullSuggestions = suggestions.filter(suggestion => {
                    return suggestion.descriptor !== null;
                });
                if (nonNullSuggestions.length === 0) {
                    const [firstError] = rejections;
                    if (typeof firstError === `undefined`)
                        throw new Error(`Assertion failed: Expected an error to have been set`);
                    const prettyError = this.cli.error(firstError);
                    if (!project.configuration.get(`enableNetwork`)) {
                        report.reportError(core_1.MessageName.CANT_SUGGEST_RESOLUTIONS, `${core_3.structUtils.prettyDescriptor(configuration, request)} can't be resolved to a satisfying range (note: network resolution has been disabled):\n\n${prettyError}`);
                    }
                    else {
                        report.reportError(core_1.MessageName.CANT_SUGGEST_RESOLUTIONS, `${core_3.structUtils.prettyDescriptor(configuration, request)} can't be resolved to a satisfying range:\n\n${prettyError}`);
                    }
                }
            }
        });
        if (checkReport.hasErrors())
            return checkReport.exitCode();
        let askedQuestions = false;
        const afterWorkspaceDependencyAdditionList = [];
        const afterWorkspaceDependencyReplacementList = [];
        for (const [/*request*/ , { suggestions }, target] of allSuggestions) {
            let selected;
            const nonNullSuggestions = suggestions.filter(suggestion => {
                return suggestion.descriptor !== null;
            });
            const firstSuggestedDescriptor = nonNullSuggestions[0].descriptor;
            const areAllTheSame = nonNullSuggestions.every(suggestion => core_3.structUtils.areDescriptorsEqual(suggestion.descriptor, firstSuggestedDescriptor));
            if (nonNullSuggestions.length === 1 || areAllTheSame) {
                selected = firstSuggestedDescriptor;
            }
            else {
                askedQuestions = true;
                ({ answer: selected } = await enquirer_1.prompt({
                    type: `select`,
                    name: `answer`,
                    message: `Which range do you want to use?`,
                    choices: suggestions.map(({ descriptor, name, reason }) => descriptor ? {
                        name,
                        hint: reason,
                        descriptor,
                    } : {
                        name,
                        hint: reason,
                        disabled: true,
                    }),
                    onCancel: () => process.exit(130),
                    result(name) {
                        // @ts-expect-error: The enquirer types don't include find
                        return this.find(name, `descriptor`);
                    },
                    stdin: this.context.stdin,
                    stdout: this.context.stdout,
                }));
            }
            const current = workspace.manifest[target].get(selected.identHash);
            if (typeof current === `undefined` || current.descriptorHash !== selected.descriptorHash) {
                workspace.manifest[target].set(selected.identHash, selected);
                if (this.optional) {
                    if (target === `dependencies`) {
                        workspace.manifest.ensureDependencyMeta({
                            ...selected,
                            range: `unknown`,
                        }).optional = true;
                    }
                    else if (target === `peerDependencies`) {
                        workspace.manifest.ensurePeerDependencyMeta({
                            ...selected,
                            range: `unknown`,
                        }).optional = true;
                    }
                }
                if (typeof current === `undefined`) {
                    afterWorkspaceDependencyAdditionList.push([
                        workspace,
                        target,
                        selected,
                        strategies,
                    ]);
                }
                else {
                    afterWorkspaceDependencyReplacementList.push([
                        workspace,
                        target,
                        current,
                        selected,
                    ]);
                }
            }
        }
        await configuration.triggerMultipleHooks((hooks) => hooks.afterWorkspaceDependencyAddition, afterWorkspaceDependencyAdditionList);
        await configuration.triggerMultipleHooks((hooks) => hooks.afterWorkspaceDependencyReplacement, afterWorkspaceDependencyReplacementList);
        if (askedQuestions)
            this.context.stdout.write(`\n`);
        const installReport = await core_2.StreamReport.start({
            configuration,
            json: this.json,
            stdout: this.context.stdout,
            includeLogs: !this.context.quiet,
        }, async (report) => {
            await project.install({ cache, report });
        });
        return installReport.exitCode();
    }
}
AddCommand.usage = clipanion_1.Command.Usage({
    description: `add dependencies to the project`,
    details: `
      This command adds a package to the package.json for the nearest workspace.

      - If it didn't exist before, the package will by default be added to the regular \`dependencies\` field, but this behavior can be overriden thanks to the \`-D,--dev\` flag (which will cause the dependency to be added to the \`devDependencies\` field instead) and the \`-P,--peer\` flag (which will do the same but for \`peerDependencies\`).

      - If the package was already listed in your dependencies, it will by default be upgraded whether it's part of your \`dependencies\` or \`devDependencies\` (it won't ever update \`peerDependencies\`, though).

      - If set, the \`--prefer-dev\` flag will operate as a more flexible \`-D,--dev\` in that it will add the package to your \`devDependencies\` if it isn't already listed in either \`dependencies\` or \`devDependencies\`, but it will also happily upgrade your \`dependencies\` if that's what you already use (whereas \`-D,--dev\` would throw an exception).

      - If set, the \`-O,--optional\` flag will add the package to the \`optionalDependencies\` field and, in combination with the \`-P,--peer\` flag, it will add the package as an optional peer dependency. If the package was already listed in your \`dependencies\`, it will be upgraded to \`optionalDependencies\`. If the package was already listed in your \`peerDependencies\`, in combination with the \`-P,--peer\` flag, it will be upgraded to an optional peer dependency: \`"peerDependenciesMeta": { "<package>": { "optional": true } }\`

      - If the added package doesn't specify a range at all its \`latest\` tag will be resolved and the returned version will be used to generate a new semver range (using the \`^\` modifier by default unless otherwise configured via the \`defaultSemverRangePrefix\` configuration, or the \`~\` modifier if \`-T,--tilde\` is specified, or no modifier at all if \`-E,--exact\` is specified). Two exceptions to this rule: the first one is that if the package is a workspace then its local version will be used, and the second one is that if you use \`-P,--peer\` the default range will be \`*\` and won't be resolved at all.

      - If the added package specifies a range (such as \`^1.0.0\`, \`latest\`, or \`rc\`), Yarn will add this range as-is in the resulting package.json entry (in particular, tags such as \`rc\` will be encoded as-is rather than being converted into a semver range).

      If the \`--cached\` option is used, Yarn will preferably reuse the highest version already used somewhere within the project, even if through a transitive dependency.

      If the \`-i,--interactive\` option is used (or if the \`preferInteractive\` settings is toggled on) the command will first try to check whether other workspaces in the project use the specified package and, if so, will offer to reuse them.

      For a compilation of all the supported protocols, please consult the dedicated page from our website: https://yarnpkg.com/features/protocols.
    `,
    examples: [[
            `Add a regular package to the current workspace`,
            `$0 add lodash`,
        ], [
            `Add a specific version for a package to the current workspace`,
            `$0 add lodash@1.2.3`,
        ], [
            `Add a package from a GitHub repository (the master branch) to the current workspace using a URL`,
            `$0 add lodash@https://github.com/lodash/lodash`,
        ], [
            `Add a package from a GitHub repository (the master branch) to the current workspace using the GitHub protocol`,
            `$0 add lodash@github:lodash/lodash`,
        ], [
            `Add a package from a GitHub repository (the master branch) to the current workspace using the GitHub protocol (shorthand)`,
            `$0 add lodash@lodash/lodash`,
        ], [
            `Add a package from a specific branch of a GitHub repository to the current workspace using the GitHub protocol (shorthand)`,
            `$0 add lodash-es@lodash/lodash#es`,
        ]],
});
tslib_1.__decorate([
    clipanion_1.Command.Rest()
], AddCommand.prototype, "packages", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`--json`, { description: `Format the output as an NDJSON stream` })
], AddCommand.prototype, "json", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`-E,--exact`, { description: `Don't use any semver modifier on the resolved range` })
], AddCommand.prototype, "exact", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`-T,--tilde`, { description: `Use the \`~\` semver modifier on the resolved range` })
], AddCommand.prototype, "tilde", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`-C,--caret`, { description: `Use the \`^\` semver modifier on the resolved range` })
], AddCommand.prototype, "caret", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`-D,--dev`, { description: `Add a package as a dev dependency` })
], AddCommand.prototype, "dev", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`-P,--peer`, { description: `Add a package as a peer dependency` })
], AddCommand.prototype, "peer", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`-O,--optional`, { description: `Add / upgrade a package to an optional regular / peer dependency` })
], AddCommand.prototype, "optional", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`--prefer-dev`, { description: `Add / upgrade a package to a dev dependency` })
], AddCommand.prototype, "preferDev", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`-i,--interactive`, { description: `Reuse the specified package from other workspaces in the project` })
], AddCommand.prototype, "interactive", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`--cached`, { description: `Reuse the highest version already used somewhere within the project` })
], AddCommand.prototype, "cached", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Path(`add`)
], AddCommand.prototype, "execute", null);
exports.default = AddCommand;
function suggestTarget(workspace, ident, { dev, peer, preferDev, optional }) {
    const hasRegular = workspace.manifest[suggestUtils.Target.REGULAR].has(ident.identHash);
    const hasDev = workspace.manifest[suggestUtils.Target.DEVELOPMENT].has(ident.identHash);
    const hasPeer = workspace.manifest[suggestUtils.Target.PEER].has(ident.identHash);
    if ((dev || peer) && hasRegular)
        throw new clipanion_1.UsageError(`Package "${core_3.structUtils.prettyIdent(workspace.project.configuration, ident)}" is already listed as a regular dependency - remove the -D,-P flags or remove it from your dependencies first`);
    if (!dev && !peer && hasPeer)
        throw new clipanion_1.UsageError(`Package "${core_3.structUtils.prettyIdent(workspace.project.configuration, ident)}" is already listed as a peer dependency - use either of -D or -P, or remove it from your peer dependencies first`);
    if (optional && hasDev)
        throw new clipanion_1.UsageError(`Package "${core_3.structUtils.prettyIdent(workspace.project.configuration, ident)}" is already listed as a dev dependency - remove the -O flag or remove it from your dev dependencies first`);
    if (optional && !peer && hasPeer)
        throw new clipanion_1.UsageError(`Package "${core_3.structUtils.prettyIdent(workspace.project.configuration, ident)}" is already listed as a peer dependency - remove the -O flag or add the -P flag or remove it from your peer dependencies first`);
    if ((dev || preferDev) && optional)
        throw new clipanion_1.UsageError(`Package "${core_3.structUtils.prettyIdent(workspace.project.configuration, ident)}" cannot simultaneously be a dev dependency and an optional dependency`);
    if (peer)
        return suggestUtils.Target.PEER;
    if (dev || preferDev)
        return suggestUtils.Target.DEVELOPMENT;
    if (hasRegular)
        return suggestUtils.Target.REGULAR;
    if (hasDev)
        return suggestUtils.Target.DEVELOPMENT;
    return suggestUtils.Target.REGULAR;
}
