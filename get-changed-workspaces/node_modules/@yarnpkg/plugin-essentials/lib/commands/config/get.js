"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const cli_1 = require("@yarnpkg/cli");
const core_1 = require("@yarnpkg/core");
const clipanion_1 = require("clipanion");
const get_1 = tslib_1.__importDefault(require("lodash/get"));
const util_1 = require("util");
// eslint-disable-next-line arca/no-default-export
class ConfigSetCommand extends cli_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.json = false;
        this.unsafe = false;
    }
    async execute() {
        const configuration = await core_1.Configuration.find(this.context.cwd, this.context.plugins);
        const name = this.name.replace(/[.[].*$/, ``);
        const path = this.name.replace(/^[^.[]*/, ``);
        const setting = configuration.settings.get(name);
        if (typeof setting === `undefined`)
            throw new clipanion_1.UsageError(`Couldn't find a configuration settings named "${name}"`);
        const displayedValue = configuration.getSpecial(name, {
            hideSecrets: !this.unsafe,
            getNativePaths: true,
        });
        const asObject = core_1.miscUtils.convertMapsToIndexableObjects(displayedValue);
        const requestedObject = path
            ? get_1.default(asObject, path)
            : asObject;
        const report = await core_1.StreamReport.start({
            configuration,
            includeFooter: false,
            json: this.json,
            stdout: this.context.stdout,
        }, async (report) => {
            report.reportJson(requestedObject);
        });
        if (!this.json) {
            if (typeof requestedObject === `string`) {
                this.context.stdout.write(`${requestedObject}\n`);
                return report.exitCode();
            }
            // @ts-expect-error: The Node typings forgot one field
            util_1.inspect.styles.name = `cyan`;
            this.context.stdout.write(`${util_1.inspect(requestedObject, {
                depth: Infinity,
                colors: configuration.get(`enableColors`),
                compact: false,
            })}\n`);
        }
        return report.exitCode();
    }
}
ConfigSetCommand.usage = clipanion_1.Command.Usage({
    description: `read a configuration settings`,
    details: `
      This command will print a configuration setting.

      Secrets (such as tokens) will be redacted from the output by default. If this behavior isn't desired, set the \`--no-redacted\` to get the untransformed value.
    `,
    examples: [[
            `Print a simple configuration setting`,
            `yarn config get yarnPath`,
        ], [
            `Print a complex configuration setting`,
            `yarn config get packageExtensions`,
        ], [
            `Print a nested field from the configuration`,
            `yarn config get 'npmScopes["my-company"].npmRegistryServer'`,
        ], [
            `Print a token from the configuration`,
            `yarn config get npmAuthToken --no-redacted`,
        ], [
            `Print a configuration setting as JSON`,
            `yarn config get packageExtensions --json`,
        ]],
});
tslib_1.__decorate([
    clipanion_1.Command.String()
], ConfigSetCommand.prototype, "name", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`--json`, { description: `Format the output as an NDJSON stream` })
], ConfigSetCommand.prototype, "json", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`--no-redacted`, { description: `Don't redact secrets (such as tokens) from the output` })
], ConfigSetCommand.prototype, "unsafe", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Path(`config`, `get`)
], ConfigSetCommand.prototype, "execute", null);
exports.default = ConfigSetCommand;
