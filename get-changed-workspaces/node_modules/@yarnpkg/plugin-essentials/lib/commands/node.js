"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const cli_1 = require("@yarnpkg/cli");
const clipanion_1 = require("clipanion");
// eslint-disable-next-line arca/no-default-export
class NodeCommand extends cli_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.args = [];
    }
    async execute() {
        return this.cli.run([`exec`, `node`, ...this.args]);
    }
}
NodeCommand.usage = clipanion_1.Command.Usage({
    description: `run node with the hook already setup`,
    details: `
      This command simply runs Node. It also makes sure to call it in a way that's compatible with the current project (for example, on PnP projects the environment will be setup in such a way that PnP will be correctly injected into the environment).

      The Node process will use the exact same version of Node as the one used to run Yarn itself, which might be a good way to ensure that your commands always use a consistent Node version.
    `,
    examples: [[
            `Run a Node script`,
            `$0 node ./my-script.js`,
        ]],
});
tslib_1.__decorate([
    clipanion_1.Command.Proxy()
], NodeCommand.prototype, "args", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Path(`node`)
], NodeCommand.prototype, "execute", null);
exports.default = NodeCommand;
