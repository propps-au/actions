"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.explainPeerRequirements = void 0;
const tslib_1 = require("tslib");
const cli_1 = require("@yarnpkg/cli");
const core_1 = require("@yarnpkg/core");
const clipanion_1 = require("clipanion");
const yup = tslib_1.__importStar(require("yup"));
// eslint-disable-next-line arca/no-default-export
class ExplainPeerRequirementsCommand extends cli_1.BaseCommand {
    async execute() {
        const configuration = await core_1.Configuration.find(this.context.cwd, this.context.plugins);
        const { project } = await core_1.Project.find(configuration, this.context.cwd);
        // peerRequirements aren't stored inside the install state
        await project.applyLightResolution();
        if (typeof this.hash !== `undefined`) {
            return await explainPeerRequirements(this.hash, project, {
                stdout: this.context.stdout,
            });
        }
        const report = await core_1.StreamReport.start({
            configuration,
            stdout: this.context.stdout,
            includeFooter: false,
        }, async (report) => {
            var _a;
            const sortCriterias = [
                ([, requirement]) => core_1.structUtils.stringifyLocator(project.storedPackages.get(requirement.subject)),
                ([, requirement]) => core_1.structUtils.stringifyIdent(requirement.requested),
            ];
            for (const [hash, requirement] of core_1.miscUtils.sortMap(project.peerRequirements, sortCriterias)) {
                const subject = project.storedPackages.get(requirement.subject);
                if (typeof subject === `undefined`)
                    throw new Error(`Assertion failed: Expected the subject package to have been registered`);
                const rootRequester = project.storedPackages.get(requirement.rootRequester);
                if (typeof rootRequester === `undefined`)
                    throw new Error(`Assertion failed: Expected the root package to have been registered`);
                const providedDescriptor = (_a = subject.dependencies.get(requirement.requested.identHash)) !== null && _a !== void 0 ? _a : null;
                const prettyHash = core_1.formatUtils.pretty(configuration, hash, core_1.formatUtils.Type.CODE);
                const prettySubject = core_1.structUtils.prettyLocator(configuration, subject);
                const prettyIdent = core_1.structUtils.prettyIdent(configuration, requirement.requested);
                const prettyRoot = core_1.structUtils.prettyIdent(configuration, rootRequester);
                const descendantCount = requirement.allRequesters.length - 1;
                const pluralized = `descendant${descendantCount === 1 ? `` : `s`}`;
                const maybeDescendants = descendantCount > 0 ? ` and ${descendantCount} ${pluralized}` : ``;
                const provides = providedDescriptor !== null ? `provides` : `doesn't provide`;
                report.reportInfo(null, `${prettyHash} → ${prettySubject} ${provides} ${prettyIdent} to ${prettyRoot}${maybeDescendants}`);
            }
        });
        return report.exitCode();
    }
}
ExplainPeerRequirementsCommand.schema = yup.object().shape({
    hash: yup.string().matches(/^p[0-9a-f]{5}$/),
});
ExplainPeerRequirementsCommand.usage = clipanion_1.Command.Usage({
    description: `explain a set of peer requirements`,
    details: `
      A set of peer requirements represents all peer requirements that a dependent must satisfy when providing a given peer request to a requester and its descendants.

      When the hash argument is specified, this command prints a detailed explanation of all requirements of the set corresponding to the hash and whether they're satisfied or not.

      When used without arguments, this command lists all sets of peer requirements and the corresponding hash that can be used to get detailed information about a given set.

      **Note:** A hash is a six-letter p-prefixed code that can be obtained from peer dependency warnings or from the list of all peer requirements (\`yarn explain peer-requirements\`).
    `,
    examples: [[
            `Explain the corresponding set of peer requirements for a hash`,
            `$0 explain peer-requirements p1a4ed`,
        ], [
            `List all sets of peer requirements`,
            `$0 explain peer-requirements`,
        ]],
});
tslib_1.__decorate([
    clipanion_1.Command.String({ required: false })
], ExplainPeerRequirementsCommand.prototype, "hash", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Path(`explain`, `peer-requirements`)
], ExplainPeerRequirementsCommand.prototype, "execute", null);
exports.default = ExplainPeerRequirementsCommand;
async function explainPeerRequirements(peerRequirementsHash, project, opts) {
    const { configuration } = project;
    const requirement = project.peerRequirements.get(peerRequirementsHash);
    if (typeof requirement === `undefined`)
        throw new Error(`No peerDependency requirements found for hash: "${peerRequirementsHash}"`);
    const report = await core_1.StreamReport.start({
        configuration,
        stdout: opts.stdout,
        includeFooter: false,
    }, async (report) => {
        var _a, _b;
        const subject = project.storedPackages.get(requirement.subject);
        if (typeof subject === `undefined`)
            throw new Error(`Assertion failed: Expected the subject package to have been registered`);
        const rootRequester = project.storedPackages.get(requirement.rootRequester);
        if (typeof rootRequester === `undefined`)
            throw new Error(`Assertion failed: Expected the root package to have been registered`);
        const providedDescriptor = (_a = subject.dependencies.get(requirement.requested.identHash)) !== null && _a !== void 0 ? _a : null;
        const providedResolution = providedDescriptor !== null
            ? project.storedResolutions.get(providedDescriptor.descriptorHash)
            : null;
        if (typeof providedResolution === `undefined`)
            throw new Error(`Assertion failed: Expected the resolution to have been registered`);
        const provided = providedResolution !== null
            ? project.storedPackages.get(providedResolution)
            : null;
        if (typeof provided === `undefined`)
            throw new Error(`Assertion failed: Expected the provided package to have been registered`);
        const allRequesters = [...requirement.allRequesters.values()].map(requesterHash => {
            const pkg = project.storedPackages.get(requesterHash);
            if (typeof pkg === `undefined`)
                throw new Error(`Assertion failed: Expected the package to be registered`);
            const devirtualizedLocator = core_1.structUtils.devirtualizeLocator(pkg);
            const devirtualizedPkg = project.storedPackages.get(devirtualizedLocator.locatorHash);
            if (typeof devirtualizedPkg === `undefined`)
                throw new Error(`Assertion failed: Expected the package to be registered`);
            const peerDependency = devirtualizedPkg.peerDependencies.get(requirement.requested.identHash);
            if (typeof peerDependency === `undefined`)
                throw new Error(`Assertion failed: Expected the peer dependency to be registered`);
            return { pkg, peerDependency };
        });
        if (provided !== null) {
            const satisfiesAllRanges = allRequesters.every(({ peerDependency }) => {
                return core_1.semverUtils.satisfiesWithPrereleases(provided.version, peerDependency.range);
            });
            report.reportInfo(core_1.MessageName.UNNAMED, `${core_1.structUtils.prettyLocator(configuration, subject)} provides ${core_1.structUtils.prettyLocator(configuration, provided)} with version ${core_1.structUtils.prettyReference(configuration, (_b = provided.version) !== null && _b !== void 0 ? _b : `<missing>`)}, which ${satisfiesAllRanges ? `satisfies` : `doesn't satisfy`} the following requirements:`);
        }
        else {
            report.reportInfo(core_1.MessageName.UNNAMED, `${core_1.structUtils.prettyLocator(configuration, subject)} doesn't provide ${core_1.structUtils.prettyIdent(configuration, requirement.requested)}, breaking the following requirements:`);
        }
        report.reportSeparator();
        const Mark = core_1.formatUtils.mark(configuration);
        const requirements = [];
        for (const { pkg, peerDependency } of core_1.miscUtils.sortMap(allRequesters, requester => core_1.structUtils.stringifyLocator(requester.pkg))) {
            const isSatisfied = provided !== null
                ? core_1.semverUtils.satisfiesWithPrereleases(provided.version, peerDependency.range)
                : false;
            const mark = isSatisfied ? Mark.Check : Mark.Cross;
            requirements.push({
                stringifiedLocator: core_1.structUtils.stringifyLocator(pkg),
                prettyLocator: core_1.structUtils.prettyLocator(configuration, pkg),
                prettyRange: core_1.structUtils.prettyRange(configuration, peerDependency.range),
                mark,
            });
        }
        const maxStringifiedLocatorLength = Math.max(...requirements.map(({ stringifiedLocator }) => stringifiedLocator.length));
        const maxPrettyRangeLength = Math.max(...requirements.map(({ prettyRange }) => prettyRange.length));
        for (const { stringifiedLocator, prettyLocator, prettyRange, mark } of core_1.miscUtils.sortMap(requirements, ({ stringifiedLocator }) => stringifiedLocator)) {
            report.reportInfo(null, `${
            // We have to do this because prettyLocators can contain multiple colors
            prettyLocator.padEnd(maxStringifiedLocatorLength + (prettyLocator.length - stringifiedLocator.length), ` `)} → ${prettyRange.padEnd(maxPrettyRangeLength, ` `)} ${mark}`);
        }
        if (requirements.length > 1) {
            report.reportSeparator();
            report.reportInfo(core_1.MessageName.UNNAMED, `Note: these requirements start with ${core_1.structUtils.prettyLocator(project.configuration, rootRequester)}`);
        }
    });
    return report.exitCode();
}
exports.explainPeerRequirements = explainPeerRequirements;
