"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.dedupe = exports.acceptedStrategies = exports.Strategy = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@yarnpkg/core");
const core_2 = require("@yarnpkg/core");
const micromatch_1 = tslib_1.__importDefault(require("micromatch"));
var Strategy;
(function (Strategy) {
    /**
     * This strategy dedupes a locator to the best candidate already installed in the project.
     *
     * Because of this, it's guaranteed that:
     * - it never takes more than a single pass to dedupe all dependencies
     * - dependencies are never downgraded
     */
    Strategy["HIGHEST"] = "highest";
})(Strategy = exports.Strategy || (exports.Strategy = {}));
exports.acceptedStrategies = new Set(Object.values(Strategy));
const DEDUPE_ALGORITHMS = {
    highest: async (project, patterns, { resolver, fetcher, resolveOptions, fetchOptions }) => {
        const locatorsByIdent = new Map();
        for (const [descriptorHash, locatorHash] of project.storedResolutions) {
            const descriptor = project.storedDescriptors.get(descriptorHash);
            if (typeof descriptor === `undefined`)
                throw new Error(`Assertion failed: The descriptor (${descriptorHash}) should have been registered`);
            core_1.miscUtils.getSetWithDefault(locatorsByIdent, descriptor.identHash).add(locatorHash);
        }
        return Array.from(project.storedDescriptors.values(), async (descriptor) => {
            if (patterns.length && !micromatch_1.default.isMatch(core_2.structUtils.stringifyIdent(descriptor), patterns))
                return null;
            const currentResolution = project.storedResolutions.get(descriptor.descriptorHash);
            if (typeof currentResolution === `undefined`)
                throw new Error(`Assertion failed: The resolution (${descriptor.descriptorHash}) should have been registered`);
            // We only care about resolutions that are stored in the lockfile
            // (we shouldn't accidentally try deduping virtual packages)
            const currentPackage = project.originalPackages.get(currentResolution);
            if (typeof currentPackage === `undefined`)
                return null;
            // No need to try deduping packages that are not persisted,
            // they will be resolved again anyways
            if (!resolver.shouldPersistResolution(currentPackage, resolveOptions))
                return null;
            const locators = locatorsByIdent.get(descriptor.identHash);
            if (typeof locators === `undefined`)
                throw new Error(`Assertion failed: The resolutions (${descriptor.identHash}) should have been registered`);
            // No need to choose when there's only one possibility
            if (locators.size === 1)
                return null;
            const references = [...locators].map(locatorHash => {
                const pkg = project.originalPackages.get(locatorHash);
                if (typeof pkg === `undefined`)
                    throw new Error(`Assertion failed: The package (${locatorHash}) should have been registered`);
                return pkg.reference;
            });
            const candidates = await resolver.getSatisfying(descriptor, references, resolveOptions);
            const bestCandidate = candidates === null || candidates === void 0 ? void 0 : candidates[0];
            if (typeof bestCandidate === `undefined`)
                return null;
            const updatedResolution = bestCandidate.locatorHash;
            const updatedPackage = project.originalPackages.get(updatedResolution);
            if (typeof updatedPackage === `undefined`)
                throw new Error(`Assertion failed: The package (${updatedResolution}) should have been registered`);
            if (updatedResolution === currentResolution)
                return null;
            return { descriptor, currentPackage, updatedPackage };
        });
    },
};
async function dedupe(project, { strategy, patterns, cache, report }) {
    const { configuration } = project;
    const throwReport = new core_1.ThrowReport();
    const resolver = configuration.makeResolver();
    const fetcher = configuration.makeFetcher();
    const fetchOptions = {
        cache,
        checksums: project.storedChecksums,
        fetcher,
        project,
        report: throwReport,
        skipIntegrityCheck: true,
    };
    const resolveOptions = {
        project,
        resolver,
        report: throwReport,
        fetchOptions,
    };
    return await report.startTimerPromise(`Deduplication step`, async () => {
        const algorithm = DEDUPE_ALGORITHMS[strategy];
        const dedupePromises = await algorithm(project, patterns, { resolver, resolveOptions, fetcher, fetchOptions });
        const progress = core_1.Report.progressViaCounter(dedupePromises.length);
        report.reportProgress(progress);
        let dedupedPackageCount = 0;
        await Promise.all(dedupePromises.map(dedupePromise => dedupePromise
            .then(dedupe => {
            if (dedupe === null)
                return;
            dedupedPackageCount++;
            const { descriptor, currentPackage, updatedPackage } = dedupe;
            report.reportInfo(core_2.MessageName.UNNAMED, `${core_2.structUtils.prettyDescriptor(configuration, descriptor)} can be deduped from ${core_2.structUtils.prettyLocator(configuration, currentPackage)} to ${core_2.structUtils.prettyLocator(configuration, updatedPackage)}`);
            report.reportJson({
                descriptor: core_2.structUtils.stringifyDescriptor(descriptor),
                currentResolution: core_2.structUtils.stringifyLocator(currentPackage),
                updatedResolution: core_2.structUtils.stringifyLocator(updatedPackage),
            });
            project.storedResolutions.set(descriptor.descriptorHash, updatedPackage.locatorHash);
        })
            .finally(() => progress.tick())));
        let packages;
        switch (dedupedPackageCount) {
            case 0:
                {
                    packages = `No packages`;
                }
                break;
            case 1:
                {
                    packages = `One package`;
                }
                break;
            default: {
                packages = `${dedupedPackageCount} packages`;
            }
        }
        const prettyStrategy = core_2.formatUtils.pretty(configuration, strategy, core_2.formatUtils.Type.CODE);
        report.reportInfo(core_2.MessageName.UNNAMED, `${packages} can be deduped using the ${prettyStrategy} strategy`);
        return dedupedPackageCount;
    });
}
exports.dedupe = dedupe;
