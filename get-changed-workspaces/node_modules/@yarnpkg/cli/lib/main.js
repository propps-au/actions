"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.main = void 0;
const core_1 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const child_process_1 = require("child_process");
const ci_info_1 = require("ci-info");
const clipanion_1 = require("clipanion");
const fs_1 = require("fs");
const pluginCommands_1 = require("./pluginCommands");
const WelcomeCommand_1 = require("./tools/WelcomeCommand");
function runBinary(path) {
    const physicalPath = fslib_1.npath.fromPortablePath(path);
    process.on(`SIGINT`, () => {
        // We don't want SIGINT to kill our process; we want it to kill the
        // innermost process, whose end will cause our own to exit.
    });
    if (physicalPath) {
        child_process_1.execFileSync(process.execPath, [physicalPath, ...process.argv.slice(2)], {
            stdio: `inherit`,
            env: {
                ...process.env,
                YARN_IGNORE_PATH: `1`,
                YARN_IGNORE_CWD: `1`,
            },
        });
    }
    else {
        child_process_1.execFileSync(physicalPath, process.argv.slice(2), {
            stdio: `inherit`,
            env: {
                ...process.env,
                YARN_IGNORE_PATH: `1`,
                YARN_IGNORE_CWD: `1`,
            },
        });
    }
}
async function main({ binaryVersion, pluginConfiguration }) {
    async function run() {
        const cli = new clipanion_1.Cli({
            binaryLabel: `Yarn Package Manager`,
            binaryName: `yarn`,
            binaryVersion,
        });
        cli.register(WelcomeCommand_1.WelcomeCommand);
        try {
            await exec(cli);
        }
        catch (error) {
            process.stdout.write(cli.error(error));
            process.exitCode = 1;
        }
    }
    async function exec(cli) {
        // Non-exhaustive known requirements:
        // - 10.16+ for Brotli support on `plugin-compat`
        // - 10.17+ to silence `got` warning on `dns.promises`
        // - 14.0 and 14.1 empty http responses - https://github.com/sindresorhus/got/issues/1496
        var _a, _b, _c, _d, _e;
        const version = process.versions.node;
        const range = `>=10.17 <14 || >14.1`;
        if (process.env.YARN_IGNORE_NODE !== `1` && !core_1.semverUtils.satisfiesWithPrereleases(version, range))
            throw new clipanion_1.UsageError(`This tool requires a Node version compatible with ${range} (got ${version}). Upgrade Node, or set \`YARN_IGNORE_NODE=1\` in your environment.`);
        // Since we only care about a few very specific settings (yarn-path and ignore-path) we tolerate extra configuration key.
        // If we didn't, we wouldn't even be able to run `yarn config` (which is recommended in the invalid config error message)
        const configuration = await core_1.Configuration.find(fslib_1.npath.toPortablePath(process.cwd()), pluginConfiguration, {
            usePath: true,
            strict: false,
        });
        const yarnPath = configuration.get(`yarnPath`);
        const ignorePath = configuration.get(`ignorePath`);
        const ignoreCwd = configuration.get(`ignoreCwd`);
        // Avoid unnecessary spawn when run directly
        if (!ignorePath && !ignoreCwd && yarnPath === fslib_1.npath.toPortablePath(fslib_1.npath.resolve(process.argv[1]))) {
            process.env.YARN_IGNORE_PATH = `1`;
            process.env.YARN_IGNORE_CWD = `1`;
            await exec(cli);
            return;
        }
        else if (yarnPath !== null && !ignorePath) {
            if (!fslib_1.xfs.existsSync(yarnPath)) {
                process.stdout.write(cli.error(new Error(`The "yarn-path" option has been set (in ${configuration.sources.get(`yarnPath`)}), but the specified location doesn't exist (${yarnPath}).`)));
                process.exitCode = 1;
            }
            else {
                try {
                    runBinary(yarnPath);
                }
                catch (error) {
                    process.exitCode = error.code || 1;
                }
            }
        }
        else {
            if (ignorePath)
                delete process.env.YARN_IGNORE_PATH;
            const isTelemetryEnabled = configuration.get(`enableTelemetry`);
            if (isTelemetryEnabled && !ci_info_1.isCI && process.stdout.isTTY)
                core_1.Configuration.telemetry = new core_1.TelemetryManager(configuration, `puba9cdc10ec5790a2cf4969dd413a47270`);
            (_a = core_1.Configuration.telemetry) === null || _a === void 0 ? void 0 : _a.reportVersion(binaryVersion);
            for (const [name, plugin] of configuration.plugins.entries()) {
                if (pluginCommands_1.pluginCommands.has((_c = (_b = name.match(/^@yarnpkg\/plugin-(.*)$/)) === null || _b === void 0 ? void 0 : _b[1]) !== null && _c !== void 0 ? _c : ``))
                    (_d = core_1.Configuration.telemetry) === null || _d === void 0 ? void 0 : _d.reportPluginName(name);
                for (const command of plugin.commands || []) {
                    cli.register(command);
                }
            }
            const command = cli.process(process.argv.slice(2));
            if (!command.help)
                (_e = core_1.Configuration.telemetry) === null || _e === void 0 ? void 0 : _e.reportCommandName(command.path.join(` `));
            // @ts-expect-error: The cwd is a global option defined by BaseCommand
            const cwd = command.cwd;
            if (typeof cwd !== `undefined` && !ignoreCwd) {
                const iAmHere = fs_1.realpathSync(process.cwd());
                const iShouldBeHere = fs_1.realpathSync(cwd);
                if (iAmHere !== iShouldBeHere) {
                    process.chdir(cwd);
                    await run();
                    return;
                }
            }
            await cli.runExit(command, {
                cwd: fslib_1.npath.toPortablePath(process.cwd()),
                plugins: pluginConfiguration,
                quiet: false,
                stdin: process.stdin,
                stdout: process.stdout,
                stderr: process.stderr,
            });
        }
    }
    return run()
        .catch(error => {
        process.stdout.write(error.stack || error.message);
        process.exitCode = 1;
    })
        .finally(() => fslib_1.xfs.rmtempPromise());
}
exports.main = main;
