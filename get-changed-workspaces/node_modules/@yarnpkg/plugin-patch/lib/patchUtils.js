"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.diffFolders = exports.extractPackageToDisk = exports.loadPatchFiles = exports.isParentRequired = exports.makeLocator = exports.makeDescriptor = exports.parseLocator = exports.parseDescriptor = exports.parsePatchFile = exports.applyPatchFile = void 0;
const core_1 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
var apply_1 = require("./tools/apply");
Object.defineProperty(exports, "applyPatchFile", { enumerable: true, get: function () { return apply_1.applyPatchFile; } });
var parse_1 = require("./tools/parse");
Object.defineProperty(exports, "parsePatchFile", { enumerable: true, get: function () { return parse_1.parsePatchFile; } });
const BUILTIN_REGEXP = /^builtin<([^>]+)>$/;
function parseSpec(spec, sourceParser) {
    const { source, selector, params } = core_1.structUtils.parseRange(spec);
    if (source === null)
        throw new Error(`Patch locators must explicitly define their source`);
    const patchPaths = selector
        ? selector.split(/&/).map(path => fslib_1.npath.toPortablePath(path))
        : [];
    const parentLocator = params && typeof params.locator === `string`
        ? core_1.structUtils.parseLocator(params.locator)
        : null;
    const sourceVersion = params && typeof params.version === `string`
        ? params.version
        : null;
    const sourceItem = sourceParser(source);
    return { parentLocator, sourceItem, patchPaths, sourceVersion };
}
function parseDescriptor(descriptor) {
    const { sourceItem, ...rest } = parseSpec(descriptor.range, core_1.structUtils.parseDescriptor);
    return { ...rest, sourceDescriptor: sourceItem };
}
exports.parseDescriptor = parseDescriptor;
function parseLocator(locator) {
    const { sourceItem, ...rest } = parseSpec(locator.reference, core_1.structUtils.parseLocator);
    return { ...rest, sourceLocator: sourceItem };
}
exports.parseLocator = parseLocator;
function makeSpec({ parentLocator, sourceItem, patchPaths, sourceVersion, patchHash }, sourceStringifier) {
    const parentLocatorSpread = parentLocator !== null
        ? { locator: core_1.structUtils.stringifyLocator(parentLocator) }
        : {};
    const sourceVersionSpread = typeof sourceVersion !== `undefined`
        ? { version: sourceVersion }
        : {};
    const patchHashSpread = typeof patchHash !== `undefined`
        ? { hash: patchHash }
        : {};
    return core_1.structUtils.makeRange({
        protocol: `patch:`,
        source: sourceStringifier(sourceItem),
        selector: patchPaths.join(`&`),
        params: {
            ...sourceVersionSpread,
            ...patchHashSpread,
            ...parentLocatorSpread,
        },
    });
}
function makeDescriptor(ident, { parentLocator, sourceDescriptor, patchPaths }) {
    return core_1.structUtils.makeLocator(ident, makeSpec({ parentLocator, sourceItem: sourceDescriptor, patchPaths }, core_1.structUtils.stringifyDescriptor));
}
exports.makeDescriptor = makeDescriptor;
function makeLocator(ident, { parentLocator, sourcePackage, patchPaths, patchHash }) {
    return core_1.structUtils.makeLocator(ident, makeSpec({ parentLocator, sourceItem: sourcePackage, sourceVersion: sourcePackage.version, patchPaths, patchHash }, core_1.structUtils.stringifyLocator));
}
exports.makeLocator = makeLocator;
function visitPatchPath({ onAbsolute, onRelative, onBuiltin }, patchPath) {
    const builtinMatch = patchPath.match(BUILTIN_REGEXP);
    if (builtinMatch !== null)
        return onBuiltin(builtinMatch[1]);
    if (fslib_1.ppath.isAbsolute(patchPath)) {
        return onAbsolute(patchPath);
    }
    else {
        return onRelative(patchPath);
    }
}
function isParentRequired(patchPath) {
    return visitPatchPath({
        onAbsolute: () => false,
        onRelative: () => true,
        onBuiltin: () => false,
    }, patchPath);
}
exports.isParentRequired = isParentRequired;
async function loadPatchFiles(parentLocator, patchPaths, opts) {
    // When the patch files use absolute paths we can directly access them via
    // their location on the disk. Otherwise we must go through the package fs.
    const parentFetch = parentLocator !== null
        ? await opts.fetcher.fetch(parentLocator, opts)
        : null;
    // If the package fs publicized its "original location" (for example like
    // in the case of "file:" packages), we use it to derive the real location.
    const effectiveParentFetch = parentFetch && parentFetch.localPath
        ? { packageFs: new fslib_1.CwdFS(fslib_1.PortablePath.root), prefixPath: fslib_1.ppath.relative(fslib_1.PortablePath.root, parentFetch.localPath) }
        : parentFetch;
    // Discard the parent fs unless we really need it to access the files
    if (parentFetch && parentFetch !== effectiveParentFetch && parentFetch.releaseFs)
        parentFetch.releaseFs();
    // First we obtain the specification for all the patches that we'll have to
    // apply to the original package.
    const patchFiles = await core_1.miscUtils.releaseAfterUseAsync(async () => {
        return await Promise.all(patchPaths.map(async (patchPath) => visitPatchPath({
            onAbsolute: async () => {
                return await fslib_1.xfs.readFilePromise(patchPath, `utf8`);
            },
            onRelative: async () => {
                if (parentFetch === null)
                    throw new Error(`Assertion failed: The parent locator should have been fetched`);
                return await parentFetch.packageFs.readFilePromise(patchPath, `utf8`);
            },
            onBuiltin: async (name) => {
                return await opts.project.configuration.firstHook((hooks) => {
                    return hooks.getBuiltinPatch;
                }, opts.project, name);
            },
        }, patchPath)));
    });
    // Normalizes the line endings to prevent mismatches when cloning a
    // repository on Windows systems (the default settings for Git are to
    // convert newlines back and forth, which would mess with the checksum)
    return patchFiles.map(definition => {
        if (typeof definition === `string`) {
            return definition.replace(/\r\n?/g, `\n`);
        }
        else {
            return definition;
        }
    });
}
exports.loadPatchFiles = loadPatchFiles;
async function extractPackageToDisk(locator, { cache, project }) {
    const checksums = project.storedChecksums;
    const report = new core_1.ThrowReport();
    const fetcher = project.configuration.makeFetcher();
    const fetchResult = await fetcher.fetch(locator, { cache, project, fetcher, checksums, report });
    const temp = await fslib_1.xfs.mktempPromise();
    await fslib_1.xfs.copyPromise(temp, fetchResult.prefixPath, {
        baseFs: fetchResult.packageFs,
    });
    await fslib_1.xfs.writeJsonPromise(fslib_1.ppath.join(temp, `.yarn-patch.json`), {
        locator: core_1.structUtils.stringifyLocator(locator),
    });
    fslib_1.xfs.detachTemp(temp);
    return temp;
}
exports.extractPackageToDisk = extractPackageToDisk;
async function diffFolders(folderA, folderB) {
    const folderAN = fslib_1.npath.fromPortablePath(folderA).replace(/\\/g, `/`);
    const folderBN = fslib_1.npath.fromPortablePath(folderB).replace(/\\/g, `/`);
    const { stdout } = await core_1.execUtils.execvp(`git`, [`diff`, `--src-prefix=a/`, `--dst-prefix=b/`, `--ignore-cr-at-eol`, `--full-index`, `--no-index`, folderAN, folderBN], {
        cwd: fslib_1.npath.toPortablePath(process.cwd()),
    });
    const normalizePath = folderAN.startsWith(`/`)
        ? (p) => p.slice(1)
        : (p) => p;
    return stdout
        .replace(new RegExp(`(a|b)(${core_1.miscUtils.escapeRegExp(`/${normalizePath(folderAN)}/`)})`, `g`), `$1/`)
        .replace(new RegExp(`(a|b)${core_1.miscUtils.escapeRegExp(`/${normalizePath(folderBN)}/`)}`, `g`), `$1/`)
        .replace(new RegExp(core_1.miscUtils.escapeRegExp(`${folderAN}/`), `g`), ``)
        .replace(new RegExp(core_1.miscUtils.escapeRegExp(`${folderBN}/`), `g`), ``);
}
exports.diffFolders = diffFolders;
