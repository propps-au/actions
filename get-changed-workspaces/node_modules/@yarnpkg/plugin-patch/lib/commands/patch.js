"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const cli_1 = require("@yarnpkg/cli");
const core_1 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const clipanion_1 = require("clipanion");
const patchUtils = tslib_1.__importStar(require("../patchUtils"));
// eslint-disable-next-line arca/no-default-export
class PatchCommand extends cli_1.BaseCommand {
    async execute() {
        const configuration = await core_1.Configuration.find(this.context.cwd, this.context.plugins);
        const { project, workspace } = await core_1.Project.find(configuration, this.context.cwd);
        const cache = await core_1.Cache.find(configuration);
        if (!workspace)
            throw new cli_1.WorkspaceRequiredError(project.cwd, this.context.cwd);
        await project.restoreInstallState();
        let locator = core_1.structUtils.parseLocator(this.package);
        if (locator.reference === `unknown`) {
            const candidateLocators = core_1.miscUtils.mapAndFilter([...project.storedPackages.values()], pkg => {
                if (pkg.identHash !== locator.identHash)
                    return core_1.miscUtils.mapAndFilter.skip;
                if (core_1.structUtils.isVirtualLocator(pkg))
                    return core_1.miscUtils.mapAndFilter.skip;
                return pkg;
            });
            if (candidateLocators.length === 0)
                throw new clipanion_1.UsageError(`No package found in the project for the given locator`);
            if (candidateLocators.length > 1)
                throw new clipanion_1.UsageError(`Multiple candidate packages found; explicitly choose one of them (use \`yarn why <package>\` to get more information as to who depends on them):\n${candidateLocators.map(locator => `\n- ${core_1.structUtils.prettyLocator(configuration, locator)}`).join(``)}`);
            locator = candidateLocators[0];
        }
        if (!project.storedPackages.has(locator.locatorHash))
            throw new clipanion_1.UsageError(`No package found in the project for the given locator`);
        await core_1.StreamReport.start({
            configuration,
            stdout: this.context.stdout,
        }, async (report) => {
            const temp = await patchUtils.extractPackageToDisk(locator, { cache, project });
            report.reportInfo(core_1.MessageName.UNNAMED, `Package ${core_1.structUtils.prettyLocator(configuration, locator)} got extracted with success!`);
            report.reportInfo(core_1.MessageName.UNNAMED, `You can now edit the following folder: ${core_1.formatUtils.pretty(configuration, fslib_1.npath.fromPortablePath(temp), `magenta`)}`);
            report.reportInfo(core_1.MessageName.UNNAMED, `Once you are done run ${core_1.formatUtils.pretty(configuration, `yarn patch-commit ${fslib_1.npath.fromPortablePath(temp)}`, `cyan`)} and Yarn will store a patchfile based on your changes.`);
        });
    }
}
PatchCommand.usage = clipanion_1.Command.Usage({
    description: `
      This command will cause a package to be extracted in a temporary directory (under a folder named "patch-workdir"). This folder will be editable at will; running \`yarn patch\` inside it will then cause Yarn to generate a patchfile and register it into your top-level manifest (cf the \`patch:\` protocol).
    `,
});
tslib_1.__decorate([
    clipanion_1.Command.String()
], PatchCommand.prototype, "package", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Path(`patch`)
], PatchCommand.prototype, "execute", null);
exports.default = PatchCommand;
