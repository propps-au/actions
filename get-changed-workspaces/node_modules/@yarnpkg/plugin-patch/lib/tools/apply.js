"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.applyPatch = exports.applyPatchFile = void 0;
const core_1 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const UnmatchedHunkError_1 = require("./UnmatchedHunkError");
const parse_1 = require("./parse");
const DEFAULT_TIME = 315532800;
async function preserveTime(baseFs, p, cb) {
    const stat = await baseFs.lstatPromise(p);
    const result = await cb();
    if (typeof result !== `undefined`)
        p = result;
    if (baseFs.lutimesPromise) {
        await baseFs.lutimesPromise(p, stat.atime, stat.mtime);
    }
    else if (!stat.isSymbolicLink()) {
        await baseFs.utimesPromise(p, stat.atime, stat.mtime);
    }
    else {
        throw new Error(`Cannot preserve the time values of a symlink`);
    }
}
async function applyPatchFile(effects, { baseFs = new fslib_1.NodeFS(), dryRun = false, version = null } = {}) {
    for (const eff of effects) {
        if (eff.semverExclusivity !== null && version !== null)
            if (!core_1.semverUtils.satisfiesWithPrereleases(version, eff.semverExclusivity))
                continue;
        switch (eff.type) {
            case `file deletion`:
                {
                    if (dryRun) {
                        if (!baseFs.existsSync(eff.path)) {
                            throw new Error(`Trying to delete a file that doesn't exist: ${eff.path}`);
                        }
                    }
                    else {
                        await preserveTime(baseFs, fslib_1.ppath.dirname(eff.path), async () => {
                            await baseFs.unlinkPromise(eff.path);
                        });
                    }
                }
                break;
            case `rename`:
                {
                    if (dryRun) {
                        if (!baseFs.existsSync(eff.fromPath)) {
                            throw new Error(`Trying to move a file that doesn't exist: ${eff.fromPath}`);
                        }
                    }
                    else {
                        await preserveTime(baseFs, fslib_1.ppath.dirname(eff.fromPath), async () => {
                            await preserveTime(baseFs, fslib_1.ppath.dirname(eff.toPath), async () => {
                                await preserveTime(baseFs, eff.fromPath, async () => {
                                    await baseFs.movePromise(eff.fromPath, eff.toPath);
                                    return eff.toPath;
                                });
                            });
                        });
                    }
                }
                break;
            case `file creation`:
                {
                    if (dryRun) {
                        if (baseFs.existsSync(eff.path)) {
                            throw new Error(`Trying to create a file that already exists: ${eff.path}`);
                        }
                    }
                    else {
                        const fileContents = eff.hunk
                            ? eff.hunk.parts[0].lines.join(`\n`) + (eff.hunk.parts[0].noNewlineAtEndOfFile ? `` : `\n`)
                            : ``;
                        // Todo: the parent of the first directory thus created will still see its mtime changed
                        await baseFs.mkdirpPromise(fslib_1.ppath.dirname(eff.path), { chmod: 0o755, utimes: [DEFAULT_TIME, DEFAULT_TIME] });
                        await baseFs.writeFilePromise(eff.path, fileContents, { mode: eff.mode });
                        await baseFs.utimesPromise(eff.path, DEFAULT_TIME, DEFAULT_TIME);
                    }
                }
                break;
            case `patch`:
                {
                    await preserveTime(baseFs, eff.path, async () => {
                        await applyPatch(eff, { baseFs, dryRun });
                    });
                }
                break;
            case `mode change`:
                {
                    const currentStat = await baseFs.statPromise(eff.path);
                    const currentMode = currentStat.mode;
                    if (isExecutable(eff.newMode) !== isExecutable(currentMode))
                        continue;
                    await preserveTime(baseFs, eff.path, async () => {
                        await baseFs.chmodPromise(eff.path, eff.newMode);
                    });
                }
                break;
            default:
                {
                    core_1.miscUtils.assertNever(eff);
                }
                break;
        }
    }
}
exports.applyPatchFile = applyPatchFile;
function isExecutable(fileMode) {
    return (fileMode & 0o100) > 0;
}
function trimRight(s) {
    return s.replace(/\s+$/, ``);
}
function linesAreEqual(a, b) {
    return trimRight(a) === trimRight(b);
}
/**
 * How does noNewLineAtEndOfFile work?
 *
 * if you remove the newline from a file that had one without editing other bits:
 *
 *    it creates an insertion/removal pair where the insertion has \ No new line at end of file
 *
 * if you edit a file that didn't have a new line and don't add one:
 *
 *    both insertion and deletion have \ No new line at end of file
 *
 * if you edit a file that didn't have a new line and add one:
 *
 *    deletion has \ No new line at end of file
 *    but not insertion
 *
 * if you edit a file that had a new line and leave it in:
 *
 *    neither insetion nor deletion have the annoation
 *
 */
async function applyPatch({ hunks, path }, { baseFs, dryRun = false }) {
    const mode = await baseFs.statSync(path).mode;
    const fileContents = await baseFs.readFileSync(path, `utf8`);
    const fileLines = fileContents.split(/\n/);
    const result = [];
    let fixupOffset = 0;
    let maxFrozenLine = 0;
    for (const hunk of hunks) {
        const firstGuess = Math.max(maxFrozenLine, hunk.header.patched.start + fixupOffset);
        const maxPrefixFuzz = Math.max(0, firstGuess - maxFrozenLine);
        const maxSuffixFuzz = Math.max(0, fileLines.length - firstGuess - hunk.header.original.length);
        const maxFuzz = Math.max(maxPrefixFuzz, maxSuffixFuzz);
        let offset = 0;
        let location = 0;
        let modifications = null;
        while (offset <= maxFuzz) {
            if (offset <= maxPrefixFuzz) {
                location = firstGuess - offset;
                modifications = evaluateHunk(hunk, fileLines, location);
                if (modifications !== null) {
                    offset = -offset;
                    break;
                }
            }
            if (offset <= maxSuffixFuzz) {
                location = firstGuess + offset;
                modifications = evaluateHunk(hunk, fileLines, location);
                if (modifications !== null) {
                    break;
                }
            }
            offset += 1;
        }
        if (modifications === null)
            throw new UnmatchedHunkError_1.UnmatchedHunkError(hunks.indexOf(hunk), hunk);
        result.push(modifications);
        fixupOffset += offset;
        maxFrozenLine = location + hunk.header.original.length;
    }
    if (dryRun)
        return;
    let diffOffset = 0;
    for (const modifications of result) {
        for (const modification of modifications) {
            switch (modification.type) {
                case `splice`:
                    {
                        const firstLine = modification.index + diffOffset;
                        fileLines.splice(firstLine, modification.numToDelete, ...modification.linesToInsert);
                        diffOffset += modification.linesToInsert.length - modification.numToDelete;
                    }
                    break;
                case `pop`:
                    {
                        fileLines.pop();
                    }
                    break;
                case `push`:
                    {
                        fileLines.push(modification.line);
                    }
                    break;
                default:
                    {
                        core_1.miscUtils.assertNever(modification);
                    }
                    break;
            }
        }
    }
    await baseFs.writeFilePromise(path, fileLines.join(`\n`), { mode });
}
exports.applyPatch = applyPatch;
function evaluateHunk(hunk, fileLines, offset) {
    const result = [];
    for (const part of hunk.parts) {
        switch (part.type) {
            case parse_1.PatchMutationType.Context:
            case parse_1.PatchMutationType.Deletion:
                {
                    for (const line of part.lines) {
                        const originalLine = fileLines[offset];
                        if (originalLine == null || !linesAreEqual(originalLine, line))
                            return null;
                        offset += 1;
                    }
                    if (part.type === parse_1.PatchMutationType.Deletion) {
                        result.push({
                            type: `splice`,
                            index: offset - part.lines.length,
                            numToDelete: part.lines.length,
                            linesToInsert: [],
                        });
                        if (part.noNewlineAtEndOfFile) {
                            result.push({
                                type: `push`,
                                line: ``,
                            });
                        }
                    }
                }
                break;
            case parse_1.PatchMutationType.Insertion:
                {
                    result.push({
                        type: `splice`,
                        index: offset,
                        numToDelete: 0,
                        linesToInsert: part.lines,
                    });
                    if (part.noNewlineAtEndOfFile) {
                        result.push({ type: `pop` });
                    }
                }
                break;
            default:
                {
                    core_1.miscUtils.assertNever(part.type);
                }
                break;
        }
    }
    return result;
}
