"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GitFetcher = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const gitUtils = tslib_1.__importStar(require("./gitUtils"));
class GitFetcher {
    supports(locator, opts) {
        return gitUtils.isGitUrl(locator.reference);
    }
    getLocalPath(locator, opts) {
        return null;
    }
    async fetch(locator, opts) {
        const expectedChecksum = opts.checksums.get(locator.locatorHash) || null;
        const normalizedLocator = gitUtils.normalizeLocator(locator);
        const checksums = new Map(opts.checksums);
        checksums.set(normalizedLocator.locatorHash, expectedChecksum);
        const nextOpts = { ...opts, checksums };
        const result = await this.downloadHosted(normalizedLocator, nextOpts);
        if (result !== null)
            return result;
        const [packageFs, releaseFs, checksum] = await opts.cache.fetchPackageFromCache(locator, expectedChecksum, {
            onHit: () => opts.report.reportCacheHit(locator),
            onMiss: () => opts.report.reportCacheMiss(locator, `${core_1.structUtils.prettyLocator(opts.project.configuration, locator)} can't be found in the cache and will be fetched from the remote repository`),
            loader: () => this.cloneFromRemote(normalizedLocator, nextOpts),
            skipIntegrityCheck: opts.skipIntegrityCheck,
        });
        return {
            packageFs,
            releaseFs,
            prefixPath: core_1.structUtils.getIdentVendorPath(locator),
            checksum,
        };
    }
    async downloadHosted(locator, opts) {
        return opts.project.configuration.reduceHook((hooks) => {
            return hooks.fetchHostedRepository;
        }, null, locator, opts);
    }
    async cloneFromRemote(locator, opts) {
        const cloneTarget = await gitUtils.clone(locator.reference, opts.project.configuration);
        const repoUrlParts = gitUtils.splitRepoUrl(locator.reference);
        const packagePath = fslib_1.ppath.join(cloneTarget, `package.tgz`);
        await core_1.scriptUtils.prepareExternalProject(cloneTarget, packagePath, {
            configuration: opts.project.configuration,
            report: opts.report,
            workspace: repoUrlParts.extra.workspace,
        });
        const sourceBuffer = await fslib_1.xfs.readFilePromise(packagePath);
        return await core_1.miscUtils.releaseAfterUseAsync(async () => {
            return await core_1.tgzUtils.convertToZip(sourceBuffer, {
                compressionLevel: opts.project.configuration.get(`compressionLevel`),
                prefixPath: core_1.structUtils.getIdentVendorPath(locator),
                stripComponents: 1,
            });
        });
    }
}
exports.GitFetcher = GitFetcher;
