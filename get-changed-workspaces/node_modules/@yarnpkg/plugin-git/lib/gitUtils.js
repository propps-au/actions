"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.clone = exports.resolveUrl = exports.lsRemote = exports.normalizeLocator = exports.normalizeRepoUrl = exports.splitRepoUrl = exports.isGitUrl = exports.TreeishProtocols = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const querystring_1 = tslib_1.__importDefault(require("querystring"));
const semver_1 = tslib_1.__importDefault(require("semver"));
const url_1 = tslib_1.__importDefault(require("url"));
function makeGitEnvironment() {
    return {
        ...process.env,
        // An option passed to SSH by Git to prevent SSH from asking for data (which would cause installs to hang when the SSH keys are missing)
        GIT_SSH_COMMAND: `ssh -o BatchMode=yes`,
    };
}
const gitPatterns = [
    /^ssh:/,
    /^git(?:\+[^:]+)?:/,
    // `git+` is optional, `.git` is required
    /^(?:git\+)?https?:[^#]+\/[^#]+(?:\.git)(?:#.*)?$/,
    /^git@[^#]+\/[^#]+\.git(?:#.*)?$/,
    /^(?:github:|https:\/\/github\.com\/)?(?!\.{1,2}\/)([a-zA-Z._0-9-]+)\/(?!\.{1,2}(?:#|$))([a-zA-Z._0-9-]+?)(?:\.git)?(?:#.*)?$/,
    // GitHub `/tarball/` URLs
    /^https:\/\/github\.com\/(?!\.{1,2}\/)([a-zA-Z0-9._-]+)\/(?!\.{1,2}(?:#|$))([a-zA-Z0-9._-]+?)\/tarball\/(.+)?$/,
];
var TreeishProtocols;
(function (TreeishProtocols) {
    TreeishProtocols["Commit"] = "commit";
    TreeishProtocols["Head"] = "head";
    TreeishProtocols["Tag"] = "tag";
    TreeishProtocols["Semver"] = "semver";
})(TreeishProtocols = exports.TreeishProtocols || (exports.TreeishProtocols = {}));
/**
 * Determines whether a given url is a valid github git url via regex
 */
function isGitUrl(url) {
    return url ? gitPatterns.some(pattern => !!url.match(pattern)) : false;
}
exports.isGitUrl = isGitUrl;
function splitRepoUrl(url) {
    url = normalizeRepoUrl(url);
    const hashIndex = url.indexOf(`#`);
    if (hashIndex === -1) {
        return {
            repo: url,
            treeish: {
                protocol: TreeishProtocols.Head,
                request: `master`,
            },
            extra: {},
        };
    }
    const repo = url.slice(0, hashIndex);
    const subsequent = url.slice(hashIndex + 1);
    // New-style: "#commit=abcdef&workspace=foobar"
    if (subsequent.match(/^[a-z]+=/)) {
        const extra = querystring_1.default.parse(subsequent);
        for (const [key, value] of Object.entries(extra))
            if (typeof value !== `string`)
                throw new Error(`Assertion failed: The ${key} parameter must be a literal string`);
        const requestedProtocol = Object.values(TreeishProtocols).find(protocol => {
            return Object.prototype.hasOwnProperty.call(extra, protocol);
        });
        let protocol;
        let request;
        if (typeof requestedProtocol !== `undefined`) {
            protocol = requestedProtocol;
            request = extra[requestedProtocol];
        }
        else {
            protocol = TreeishProtocols.Head;
            request = `master`;
        }
        for (const key of Object.values(TreeishProtocols))
            delete extra[key];
        return {
            repo,
            treeish: { protocol, request },
            extra: extra,
        };
    }
    // Old-style: "#commit:abcdef" or "#abcdef"
    else {
        const colonIndex = subsequent.indexOf(`:`);
        let protocol;
        let request;
        if (colonIndex === -1) {
            protocol = null;
            request = subsequent;
        }
        else {
            protocol = subsequent.slice(0, colonIndex);
            request = subsequent.slice(colonIndex + 1);
        }
        return {
            repo,
            treeish: { protocol, request },
            extra: {},
        };
    }
}
exports.splitRepoUrl = splitRepoUrl;
function normalizeRepoUrl(url, { git = false } = {}) {
    var _a;
    // "git+https://" isn't an actual Git protocol. It's just a way to
    // disambiguate that this URL points to a Git repository.
    url = url.replace(/^git\+https:/, `https:`);
    // We support this as an alias to GitHub repositories
    url = url.replace(/^(?:github:|https:\/\/github\.com\/)?(?!\.{1,2}\/)([a-zA-Z0-9._-]+)\/(?!\.{1,2}(?:#|$))([a-zA-Z0-9._-]+?)(?:\.git)?(#.*)?$/, `https://github.com/$1/$2.git$3`);
    // We support GitHub `/tarball/` URLs
    url = url.replace(/^https:\/\/github\.com\/(?!\.{1,2}\/)([a-zA-Z0-9._-]+)\/(?!\.{1,2}(?:#|$))([a-zA-Z0-9._-]+?)\/tarball\/(.+)?$/, `https://github.com/$1/$2.git#$3`);
    if (git) {
        // The `git+` prefix doesn't mean anything at all for Git
        url = url.replace(/^git\+([^:]+):/, `$1:`);
        // The `ssh://` prefix should be removed because so URLs won't work in Git:
        //   ssh://git@github.com:yarnpkg/berry.git
        //   git@github.com/yarnpkg/berry.git
        // Git only allows:
        //   git@github.com:yarnpkg/berry.git (no ssh)
        //   ssh://git@github.com/yarnpkg/berry.git (no colon)
        // So we should cut `ssh://`, but only in URLs that contain colon after the hostname
        let parsedUrl;
        try {
            parsedUrl = url_1.default.parse(url);
        }
        catch (_b) {
            parsedUrl = null;
        }
        if (parsedUrl && parsedUrl.protocol === `ssh:` && ((_a = parsedUrl.path) === null || _a === void 0 ? void 0 : _a.startsWith(`/:`))) {
            url = url.replace(/^ssh:\/\//, ``);
        }
    }
    return url;
}
exports.normalizeRepoUrl = normalizeRepoUrl;
function normalizeLocator(locator) {
    return core_1.structUtils.makeLocator(locator, normalizeRepoUrl(locator.reference));
}
exports.normalizeLocator = normalizeLocator;
async function lsRemote(repo, configuration) {
    const normalizedRepoUrl = normalizeRepoUrl(repo, { git: true });
    const networkSettings = core_1.httpUtils.getNetworkSettings(normalizedRepoUrl, { configuration });
    if (!networkSettings.enableNetwork)
        throw new Error(`Request to '${normalizedRepoUrl}' has been blocked because of your configuration settings`);
    let res;
    try {
        res = await core_1.execUtils.execvp(`git`, [`ls-remote`, `--refs`, normalizedRepoUrl], {
            cwd: configuration.startingCwd,
            env: makeGitEnvironment(),
            strict: true,
        });
    }
    catch (error) {
        error.message = `Listing the refs for ${repo} failed`;
        throw error;
    }
    const refs = new Map();
    const matcher = /^([a-f0-9]{40})\t(refs\/[^\n]+)/gm;
    let match;
    while ((match = matcher.exec(res.stdout)) !== null)
        refs.set(match[2], match[1]);
    return refs;
}
exports.lsRemote = lsRemote;
async function resolveUrl(url, configuration) {
    const { repo, treeish: { protocol, request }, extra } = splitRepoUrl(url);
    const refs = await lsRemote(repo, configuration);
    const resolve = (protocol, request) => {
        switch (protocol) {
            case TreeishProtocols.Commit: {
                if (!request.match(/^[a-f0-9]{40}$/))
                    throw new Error(`Invalid commit hash`);
                return querystring_1.default.stringify({
                    ...extra,
                    commit: request,
                });
            }
            case TreeishProtocols.Head: {
                const head = refs.get(`refs/heads/${request}`);
                if (typeof head === `undefined`)
                    throw new Error(`Unknown head ("${request}")`);
                return querystring_1.default.stringify({
                    ...extra,
                    commit: head,
                });
            }
            case TreeishProtocols.Tag: {
                const tag = refs.get(`refs/tags/${request}`);
                if (typeof tag === `undefined`)
                    throw new Error(`Unknown tag ("${request}")`);
                return querystring_1.default.stringify({
                    ...extra,
                    commit: tag,
                });
            }
            case TreeishProtocols.Semver: {
                if (!semver_1.default.validRange(request))
                    throw new Error(`Invalid range ("${request}")`);
                const semverTags = new Map([...refs.entries()].filter(([ref]) => {
                    return ref.startsWith(`refs/tags/`);
                }).map(([ref, hash]) => {
                    return [semver_1.default.parse(ref.slice(10)), hash];
                }).filter((entry) => {
                    return entry[0] !== null;
                }));
                const bestVersion = semver_1.default.maxSatisfying([...semverTags.keys()], request);
                if (bestVersion === null)
                    throw new Error(`No matching range ("${request}")`);
                return querystring_1.default.stringify({
                    ...extra,
                    commit: semverTags.get(bestVersion),
                });
            }
            case null: {
                let result;
                if ((result = tryResolve(TreeishProtocols.Commit, request)) !== null)
                    return result;
                if ((result = tryResolve(TreeishProtocols.Tag, request)) !== null)
                    return result;
                if ((result = tryResolve(TreeishProtocols.Head, request)) !== null)
                    return result;
                if (request.match(/^[a-f0-9]+$/)) {
                    throw new Error(`Couldn't resolve "${request}" as either a commit, a tag, or a head - if a commit, use the 40-characters commit hash`);
                }
                else {
                    throw new Error(`Couldn't resolve "${request}" as either a commit, a tag, or a head`);
                }
            }
            default: {
                throw new Error(`Invalid Git resolution protocol ("${protocol}")`);
            }
        }
    };
    const tryResolve = (protocol, request) => {
        try {
            return resolve(protocol, request);
        }
        catch (err) {
            return null;
        }
    };
    return `${repo}#${resolve(protocol, request)}`;
}
exports.resolveUrl = resolveUrl;
async function clone(url, configuration) {
    return await configuration.getLimit(`cloneConcurrency`)(async () => {
        const { repo, treeish: { protocol, request } } = splitRepoUrl(url);
        if (protocol !== `commit`)
            throw new Error(`Invalid treeish protocol when cloning`);
        const normalizedRepoUrl = normalizeRepoUrl(repo, { git: true });
        if (core_1.httpUtils.getNetworkSettings(normalizedRepoUrl, { configuration }).enableNetwork === false)
            throw new Error(`Request to '${normalizedRepoUrl}' has been blocked because of your configuration settings`);
        const directory = await fslib_1.xfs.mktempPromise();
        const execOpts = { cwd: directory, env: makeGitEnvironment(), strict: true };
        try {
            await core_1.execUtils.execvp(`git`, [`clone`, `-c core.autocrlf=false`, normalizedRepoUrl, fslib_1.npath.fromPortablePath(directory)], execOpts);
            await core_1.execUtils.execvp(`git`, [`checkout`, `${request}`], execOpts);
        }
        catch (error) {
            error.message = `Repository clone failed: ${error.message}`;
            throw error;
        }
        return directory;
    });
}
exports.clone = clone;
