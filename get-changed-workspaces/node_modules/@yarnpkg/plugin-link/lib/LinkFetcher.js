"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LinkFetcher = void 0;
const core_1 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const constants_1 = require("./constants");
class LinkFetcher {
    supports(locator, opts) {
        if (!locator.reference.startsWith(constants_1.LINK_PROTOCOL))
            return false;
        return true;
    }
    getLocalPath(locator, opts) {
        const { parentLocator, path } = core_1.structUtils.parseFileStyleRange(locator.reference, { protocol: constants_1.LINK_PROTOCOL });
        if (fslib_1.ppath.isAbsolute(path))
            return path;
        const parentLocalPath = opts.fetcher.getLocalPath(parentLocator, opts);
        if (parentLocalPath === null)
            return null;
        return fslib_1.ppath.resolve(parentLocalPath, path);
    }
    async fetch(locator, opts) {
        const { parentLocator, path } = core_1.structUtils.parseFileStyleRange(locator.reference, { protocol: constants_1.LINK_PROTOCOL });
        // If the link target is an absolute path we can directly access it via its
        // location on the disk. Otherwise we must go through the package fs.
        const parentFetch = fslib_1.ppath.isAbsolute(path)
            ? { packageFs: new fslib_1.CwdFS(fslib_1.PortablePath.root), prefixPath: fslib_1.PortablePath.dot, localPath: fslib_1.PortablePath.root }
            : await opts.fetcher.fetch(parentLocator, opts);
        // If the package fs publicized its "original location" (for example like
        // in the case of "file:" packages), we use it to derive the real location.
        const effectiveParentFetch = parentFetch.localPath
            ? { packageFs: new fslib_1.CwdFS(fslib_1.PortablePath.root), prefixPath: fslib_1.ppath.relative(fslib_1.PortablePath.root, parentFetch.localPath) }
            : parentFetch;
        // Discard the parent fs unless we really need it to access the files
        if (parentFetch !== effectiveParentFetch && parentFetch.releaseFs)
            parentFetch.releaseFs();
        const sourceFs = effectiveParentFetch.packageFs;
        const sourcePath = fslib_1.ppath.join(effectiveParentFetch.prefixPath, path);
        if (parentFetch.localPath) {
            return { packageFs: new fslib_1.CwdFS(sourcePath, { baseFs: sourceFs }), releaseFs: effectiveParentFetch.releaseFs, prefixPath: fslib_1.PortablePath.dot, localPath: sourcePath };
        }
        else {
            return { packageFs: new fslib_1.JailFS(sourcePath, { baseFs: sourceFs }), releaseFs: effectiveParentFetch.releaseFs, prefixPath: fslib_1.PortablePath.dot };
        }
    }
}
exports.LinkFetcher = LinkFetcher;
