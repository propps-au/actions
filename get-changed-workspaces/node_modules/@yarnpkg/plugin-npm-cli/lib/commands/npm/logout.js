"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const cli_1 = require("@yarnpkg/cli");
const core_1 = require("@yarnpkg/core");
const core_2 = require("@yarnpkg/core");
const plugin_npm_1 = require("@yarnpkg/plugin-npm");
const clipanion_1 = require("clipanion");
const login_1 = require("./login");
const LOGOUT_KEYS = new Set([
    `npmAuthIdent`,
    `npmAuthToken`,
]);
// eslint-disable-next-line arca/no-default-export
class NpmLogoutCommand extends cli_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.publish = false;
        this.all = false;
    }
    async execute() {
        const configuration = await core_1.Configuration.find(this.context.cwd, this.context.plugins);
        const checkLogout = async () => {
            var _a;
            const registry = await login_1.getRegistry({
                configuration,
                cwd: this.context.cwd,
                publish: this.publish,
                scope: this.scope,
            });
            const refreshedConfiguration = await core_1.Configuration.find(this.context.cwd, this.context.plugins);
            const fakeIdent = core_1.structUtils.makeIdent((_a = this.scope) !== null && _a !== void 0 ? _a : null, `pkg`);
            const authConfiguration = plugin_npm_1.npmConfigUtils.getAuthConfiguration(registry, {
                configuration: refreshedConfiguration,
                ident: fakeIdent,
            });
            return !authConfiguration.get(`npmAuthToken`);
        };
        const report = await core_2.StreamReport.start({
            configuration,
            stdout: this.context.stdout,
        }, async (report) => {
            if (this.all) {
                await logoutFromEverything();
                report.reportInfo(core_1.MessageName.UNNAMED, `Successfully logged out from everything`);
            }
            if (this.scope) {
                await logoutFrom(`npmScopes`, this.scope);
                if (await checkLogout())
                    report.reportInfo(core_1.MessageName.UNNAMED, `Successfully logged out from ${this.scope}`);
                else
                    report.reportWarning(core_1.MessageName.UNNAMED, `Scope authentication settings removed, but some other ones settings still apply to it`);
                return;
            }
            const registry = await login_1.getRegistry({
                configuration,
                cwd: this.context.cwd,
                publish: this.publish,
            });
            await logoutFrom(`npmRegistries`, registry);
            if (await checkLogout()) {
                report.reportInfo(core_1.MessageName.UNNAMED, `Successfully logged out from ${registry}`);
            }
            else {
                report.reportWarning(core_1.MessageName.UNNAMED, `Registry authentication settings removed, but some other ones settings still apply to it`);
            }
        });
        return report.exitCode();
    }
}
NpmLogoutCommand.usage = clipanion_1.Command.Usage({
    category: `Npm-related commands`,
    description: `logout of the npm registry`,
    details: `
      This command will log you out by modifying your local configuration (in your home folder, never in the project itself) to delete all credentials linked to a registry.

      Adding the \`-s,--scope\` flag will cause the deletion to be done against whatever registry is configured for the associated scope (see also \`npmScopes\`).

      Adding the \`--publish\` flag will cause the deletion to be done against the registry used when publishing the package (see also \`publishConfig.registry\` and \`npmPublishRegistry\`).

      Adding the \`-A,--all\` flag will cause the deletion to be done against all registries and scopes.
    `,
    examples: [[
            `Logout of the default registry`,
            `yarn npm logout`,
        ], [
            `Logout of the @my-scope scope`,
            `yarn npm logout --scope my-scope`,
        ], [
            `Logout of the publish registry for the current package`,
            `yarn npm logout --publish`,
        ], [
            `Logout of all registries`,
            `yarn npm logout --all`,
        ]],
});
tslib_1.__decorate([
    clipanion_1.Command.String(`-s,--scope`, { description: `Logout of the registry configured for a given scope` })
], NpmLogoutCommand.prototype, "scope", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`--publish`, { description: `Logout of the publish registry` })
], NpmLogoutCommand.prototype, "publish", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`-A,--all`, { description: `Logout of all registries` })
], NpmLogoutCommand.prototype, "all", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Path(`npm`, `logout`)
], NpmLogoutCommand.prototype, "execute", null);
exports.default = NpmLogoutCommand;
function removeTokenFromStore(nextStore, entryName) {
    const entry = nextStore[entryName];
    if (!core_1.miscUtils.isIndexableObject(entry))
        return false;
    const keys = new Set(Object.keys(entry));
    if ([...LOGOUT_KEYS].every(key => !keys.has(key)))
        return false;
    for (const key of LOGOUT_KEYS)
        keys.delete(key);
    if (keys.size === 0) {
        nextStore[entryName] = undefined;
        return true;
    }
    const nextEntry = { ...entry };
    for (const key of LOGOUT_KEYS)
        delete nextEntry[key];
    nextStore[entryName] = nextEntry;
    return true;
}
async function logoutFromEverything() {
    const updater = (unknownStore) => {
        let updated = false;
        const nextStore = core_1.miscUtils.isIndexableObject(unknownStore)
            ? { ...unknownStore }
            : {};
        if (nextStore.npmAuthToken) {
            delete nextStore.npmAuthToken;
            updated = true;
        }
        for (const entryName of Object.keys(nextStore))
            if (removeTokenFromStore(nextStore, entryName))
                updated = true;
        if (Object.keys(nextStore).length === 0)
            return undefined;
        if (updated) {
            return nextStore;
        }
        else {
            return unknownStore;
        }
    };
    return await core_1.Configuration.updateHomeConfiguration({
        npmRegistries: updater,
        npmScopes: updater,
    });
}
async function logoutFrom(entryType, entryName) {
    return await core_1.Configuration.updateHomeConfiguration({
        [entryType]: (unknownStore) => {
            const nextStore = core_1.miscUtils.isIndexableObject(unknownStore)
                ? unknownStore
                : {};
            if (!Object.prototype.hasOwnProperty.call(nextStore, entryName))
                return unknownStore;
            const unknownEntry = nextStore[entryName];
            const nextEntry = core_1.miscUtils.isIndexableObject(unknownEntry)
                ? unknownEntry
                : {};
            const keys = new Set(Object.keys(nextEntry));
            if ([...LOGOUT_KEYS].every(key => !keys.has(key)))
                return unknownStore;
            for (const key of LOGOUT_KEYS)
                keys.delete(key);
            if (keys.size === 0) {
                if (Object.keys(nextStore).length === 1)
                    return undefined;
                return {
                    ...nextStore,
                    [entryName]: undefined,
                };
            }
            const eraser = {};
            for (const key of LOGOUT_KEYS)
                eraser[key] = undefined;
            return {
                ...nextStore,
                [entryName]: {
                    ...nextEntry,
                    ...eraser,
                },
            };
        },
    });
}
