"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const cli_1 = require("@yarnpkg/cli");
const core_1 = require("@yarnpkg/core");
const core_2 = require("@yarnpkg/core");
const plugin_npm_1 = require("@yarnpkg/plugin-npm");
const clipanion_1 = require("clipanion");
const path_1 = tslib_1.__importDefault(require("path"));
const semver_1 = tslib_1.__importDefault(require("semver"));
const util_1 = require("util");
// eslint-disable-next-line arca/no-default-export
class InfoCommand extends cli_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.json = false;
    }
    async execute() {
        const configuration = await core_1.Configuration.find(this.context.cwd, this.context.plugins);
        const { project } = await core_1.Project.find(configuration, this.context.cwd);
        const fields = typeof this.fields !== `undefined`
            ? new Set([`name`, ...this.fields.split(/\s*,\s*/)])
            : null;
        const infos = [];
        let leadWithSeparator = false;
        const report = await core_2.StreamReport.start({
            configuration,
            includeFooter: false,
            json: this.json,
            stdout: this.context.stdout,
        }, async (report) => {
            for (const identStr of this.packages) {
                let descriptor;
                if (identStr === `.`) {
                    const workspace = project.topLevelWorkspace;
                    if (!workspace.manifest.name)
                        throw new clipanion_1.UsageError(`Missing 'name' field in ${path_1.default.join(workspace.cwd, `package.json`)}`);
                    descriptor = core_1.structUtils.makeDescriptor(workspace.manifest.name, `unknown`);
                }
                else {
                    descriptor = core_1.structUtils.parseDescriptor(identStr);
                }
                const identUrl = plugin_npm_1.npmHttpUtils.getIdentUrl(descriptor);
                let result;
                try {
                    // The information from `registry.npmjs.org/<package>`
                    result = clean(await plugin_npm_1.npmHttpUtils.get(identUrl, {
                        configuration,
                        ident: descriptor,
                        jsonResponse: true,
                    }));
                }
                catch (err) {
                    if (err.name !== `HTTPError`) {
                        throw err;
                    }
                    else if (err.response.statusCode === 404) {
                        throw new core_1.ReportError(core_2.MessageName.EXCEPTION, `Package not found`);
                    }
                    else {
                        throw new core_1.ReportError(core_2.MessageName.EXCEPTION, err.toString());
                    }
                }
                const versions = Object.keys(result.versions).sort(semver_1.default.compareLoose);
                const fallbackVersion = result[`dist-tags`].latest || versions[versions.length - 1];
                // The latest version that satisfies `descriptor.range` (if it is a valid range), else `fallbackVersion`
                let version = fallbackVersion;
                if (semver_1.default.validRange(descriptor.range)) {
                    const maxSatisfyingVersion = semver_1.default.maxSatisfying(versions, descriptor.range);
                    if (maxSatisfyingVersion !== null) {
                        version = maxSatisfyingVersion;
                    }
                    else {
                        report.reportWarning(core_2.MessageName.UNNAMED, `Unmet range ${core_1.structUtils.prettyRange(configuration, descriptor.range)}; falling back to the latest version`);
                        leadWithSeparator = true;
                    }
                }
                else if (descriptor.range !== `unknown`) {
                    report.reportWarning(core_2.MessageName.UNNAMED, `Invalid range ${core_1.structUtils.prettyRange(configuration, descriptor.range)}; falling back to the latest version`);
                    leadWithSeparator = true;
                }
                const release = result.versions[version];
                /**
                 * The merging of
                 * @see `result` - The information from `registry.npmjs.org/<package>`
                 * @see `release` - The release corresponding to `version`
                 * @see `version` - The latest version that satisfies `descriptor.range` (if it is a valid range), else `fallbackVersion`
                 * @see `versions` - All version tags of a package, sorted in ascending order
                 */
                const packageInformation = {
                    ...result,
                    ...release,
                    version,
                    versions,
                };
                let serialized;
                if (fields !== null) {
                    serialized = {};
                    for (const field of fields) {
                        // @ts-expect-error
                        const value = packageInformation[field];
                        if (typeof value !== `undefined`) {
                            serialized[field] = value;
                        }
                        else {
                            report.reportWarning(core_2.MessageName.EXCEPTION, `The '${field}' field doesn't exist inside ${core_1.structUtils.prettyIdent(configuration, descriptor)}'s informations`);
                            leadWithSeparator = true;
                            continue;
                        }
                    }
                }
                else {
                    // Remove long fields
                    if (!this.json) {
                        delete packageInformation.dist;
                        delete packageInformation.readme;
                        delete packageInformation.users;
                    }
                    serialized = packageInformation;
                }
                report.reportJson(serialized);
                if (!this.json) {
                    infos.push(serialized);
                }
            }
        });
        // @ts-expect-error: The Node typings forgot one field
        util_1.inspect.styles.name = `cyan`;
        for (const serialized of infos) {
            if (serialized !== infos[0] || leadWithSeparator)
                this.context.stdout.write(`\n`);
            this.context.stdout.write(`${util_1.inspect(serialized, {
                depth: Infinity,
                colors: true,
                compact: false,
            })}\n`);
        }
        return report.exitCode();
    }
}
InfoCommand.usage = clipanion_1.Command.Usage({
    category: `Npm-related commands`,
    description: `show information about a package`,
    details: `
      This command will fetch information about a package from the npm registry, and prints it in a tree format.

      The package does not have to be installed locally, but needs to have been published (in particular, local changes will be ignored even for workspaces).

      Append \`@<range>\` to the package argument to provide information specific to the latest version that satisfies the range. If the range is invalid or if there is no version satisfying the range, the command will print a warning and fall back to the latest version.

      If the \`-f,--fields\` option is set, it's a comma-separated list of fields which will be used to only display part of the package informations.

      By default, this command won't return the \`dist\`, \`readme\`, and \`users\` fields, since they are often very long. To explicitly request those fields, explicitly list them with the \`--fields\` flag or request the output in JSON mode.
    `,
    examples: [[
            `Show all available information about react (except the \`dist\`, \`readme\`, and \`users\` fields)`,
            `yarn npm info react`,
        ], [
            `Show all available information about react as valid JSON (including the \`dist\`, \`readme\`, and \`users\` fields)`,
            `yarn npm info react --json`,
        ], [
            `Show all available information about react 16.12.0`,
            `yarn npm info react@16.12.0`,
        ], [
            `Show the description of react`,
            `yarn npm info react --fields description`,
        ], [
            `Show all available versions of react`,
            `yarn npm info react --fields versions`,
        ], [
            `Show the readme of react`,
            `yarn npm info react --fields readme`,
        ], [
            `Show a few fields of react`,
            `yarn npm info react --fields homepage,repository`,
        ]],
});
tslib_1.__decorate([
    clipanion_1.Command.Rest()
], InfoCommand.prototype, "packages", void 0);
tslib_1.__decorate([
    clipanion_1.Command.String(`-f,--fields`, { description: `A comma-separated list of manifest fields that should be displayed` })
], InfoCommand.prototype, "fields", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`--json`, { description: `Format the output as an NDJSON stream` })
], InfoCommand.prototype, "json", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Path(`npm`, `info`)
], InfoCommand.prototype, "execute", null);
exports.default = InfoCommand;
// Remove hidden properties recursively
function clean(value) {
    if (Array.isArray(value)) {
        const result = [];
        for (let item of value) {
            item = clean(item);
            if (item) {
                result.push(item);
            }
        }
        return result;
    }
    else if (typeof value === `object` && value !== null) {
        const result = {};
        for (const key of Object.keys(value)) {
            if (key.startsWith(`_`))
                continue;
            const item = clean(value[key]);
            if (item) {
                result[key] = item;
            }
        }
        return result;
    }
    else if (value) {
        return value;
    }
    else {
        return null;
    }
}
