"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NpmSemverResolver = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@yarnpkg/core");
const core_2 = require("@yarnpkg/core");
const core_3 = require("@yarnpkg/core");
const core_4 = require("@yarnpkg/core");
const semver_1 = tslib_1.__importDefault(require("semver"));
const NpmSemverFetcher_1 = require("./NpmSemverFetcher");
const constants_1 = require("./constants");
const npmHttpUtils = tslib_1.__importStar(require("./npmHttpUtils"));
const NODE_GYP_IDENT = core_4.structUtils.makeIdent(null, `node-gyp`);
const NODE_GYP_MATCH = /\b(node-gyp|prebuild-install)\b/;
class NpmSemverResolver {
    supportsDescriptor(descriptor, opts) {
        if (!descriptor.range.startsWith(constants_1.PROTOCOL))
            return false;
        return !!core_2.semverUtils.validRange(descriptor.range.slice(constants_1.PROTOCOL.length));
    }
    supportsLocator(locator, opts) {
        if (!locator.reference.startsWith(constants_1.PROTOCOL))
            return false;
        const { selector } = core_4.structUtils.parseRange(locator.reference);
        if (!semver_1.default.valid(selector))
            return false;
        return true;
    }
    shouldPersistResolution(locator, opts) {
        return true;
    }
    bindDescriptor(descriptor, fromLocator, opts) {
        return descriptor;
    }
    getResolutionDependencies(descriptor, opts) {
        return [];
    }
    async getCandidates(descriptor, dependencies, opts) {
        const range = core_2.semverUtils.validRange(descriptor.range.slice(constants_1.PROTOCOL.length));
        if (range === null)
            throw new Error(`Expected a valid range, got ${descriptor.range.slice(constants_1.PROTOCOL.length)}`);
        const registryData = await npmHttpUtils.get(npmHttpUtils.getIdentUrl(descriptor), {
            configuration: opts.project.configuration,
            ident: descriptor,
            jsonResponse: true,
        });
        const candidates = Object.keys(registryData.versions)
            .map(version => new semver_1.default.SemVer(version))
            .filter(version => range.test(version));
        const noDeprecatedCandidates = candidates.filter(version => {
            return !registryData.versions[version.raw].deprecated;
        });
        // If there are versions that aren't deprecated, use them
        const finalCandidates = noDeprecatedCandidates.length > 0
            ? noDeprecatedCandidates
            : candidates;
        finalCandidates.sort((a, b) => {
            return -a.compare(b);
        });
        return finalCandidates.map(version => {
            const versionLocator = core_4.structUtils.makeLocator(descriptor, `${constants_1.PROTOCOL}${version.raw}`);
            const archiveUrl = registryData.versions[version.raw].dist.tarball;
            if (NpmSemverFetcher_1.NpmSemverFetcher.isConventionalTarballUrl(versionLocator, archiveUrl, { configuration: opts.project.configuration })) {
                return versionLocator;
            }
            else {
                return core_4.structUtils.bindLocator(versionLocator, { __archiveUrl: archiveUrl });
            }
        });
    }
    async getSatisfying(descriptor, references, opts) {
        const range = core_2.semverUtils.validRange(descriptor.range.slice(constants_1.PROTOCOL.length));
        if (range === null)
            throw new Error(`Expected a valid range, got ${descriptor.range.slice(constants_1.PROTOCOL.length)}`);
        return references
            .map(reference => {
            try {
                return new semver_1.default.SemVer(reference.slice(constants_1.PROTOCOL.length));
            }
            catch (_a) {
                return null;
            }
        })
            .filter((version) => version !== null)
            .filter(version => range.test(version))
            .sort((a, b) => -a.compare(b))
            .map(version => core_4.structUtils.makeLocator(descriptor, `${constants_1.PROTOCOL}${version.raw}`));
    }
    async resolve(locator, opts) {
        const { selector } = core_4.structUtils.parseRange(locator.reference);
        const version = semver_1.default.clean(selector);
        if (version === null)
            throw new core_1.ReportError(core_1.MessageName.RESOLVER_NOT_FOUND, `The npm semver resolver got selected, but the version isn't semver`);
        const registryData = await npmHttpUtils.get(npmHttpUtils.getIdentUrl(locator), {
            configuration: opts.project.configuration,
            ident: locator,
            jsonResponse: true,
        });
        if (!Object.prototype.hasOwnProperty.call(registryData, `versions`))
            throw new core_1.ReportError(core_1.MessageName.REMOTE_INVALID, `Registry returned invalid data for - missing "versions" field`);
        if (!Object.prototype.hasOwnProperty.call(registryData.versions, version))
            throw new core_1.ReportError(core_1.MessageName.REMOTE_NOT_FOUND, `Registry failed to return reference "${version}"`);
        const manifest = new core_1.Manifest();
        manifest.load(registryData.versions[version]);
        // Manually add node-gyp dependency if there is a script using it and not already set
        // This is because the npm registry will automatically add a `node-gyp rebuild` install script
        // in the metadata if there is not already an install script and a binding.gyp file exists.
        // Also, node-gyp is not always set as a dependency in packages, so it will also be added if used in scripts.
        if (!manifest.dependencies.has(NODE_GYP_IDENT.identHash) && !manifest.peerDependencies.has(NODE_GYP_IDENT.identHash)) {
            for (const value of manifest.scripts.values()) {
                if (value.match(NODE_GYP_MATCH)) {
                    manifest.dependencies.set(NODE_GYP_IDENT.identHash, core_4.structUtils.makeDescriptor(NODE_GYP_IDENT, `latest`));
                    opts.report.reportWarning(core_1.MessageName.NODE_GYP_INJECTED, `${core_4.structUtils.prettyLocator(opts.project.configuration, locator)}: Implicit dependencies on node-gyp are discouraged`);
                    break;
                }
            }
        }
        // Show deprecation warnings
        if (typeof manifest.raw.deprecated === `string`)
            opts.report.reportWarning(core_1.MessageName.DEPRECATED_PACKAGE, `${core_4.structUtils.prettyLocator(opts.project.configuration, locator)} is deprecated: ${manifest.raw.deprecated}`);
        return {
            ...locator,
            version,
            languageName: `node`,
            linkType: core_3.LinkType.HARD,
            dependencies: manifest.dependencies,
            peerDependencies: manifest.peerDependencies,
            dependenciesMeta: manifest.dependenciesMeta,
            peerDependenciesMeta: manifest.peerDependenciesMeta,
            bin: manifest.bin,
        };
    }
}
exports.NpmSemverResolver = NpmSemverResolver;
