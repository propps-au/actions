"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TarballHttpFetcher = void 0;
const core_1 = require("@yarnpkg/core");
const constants_1 = require("./constants");
class TarballHttpFetcher {
    supports(locator, opts) {
        if (!constants_1.TARBALL_REGEXP.test(locator.reference))
            return false;
        if (constants_1.PROTOCOL_REGEXP.test(locator.reference))
            return true;
        return false;
    }
    getLocalPath(locator, opts) {
        return null;
    }
    async fetch(locator, opts) {
        const expectedChecksum = opts.checksums.get(locator.locatorHash) || null;
        const [packageFs, releaseFs, checksum] = await opts.cache.fetchPackageFromCache(locator, expectedChecksum, {
            onHit: () => opts.report.reportCacheHit(locator),
            onMiss: () => opts.report.reportCacheMiss(locator, `${core_1.structUtils.prettyLocator(opts.project.configuration, locator)} can't be found in the cache and will be fetched from the remote server`),
            loader: () => this.fetchFromNetwork(locator, opts),
            skipIntegrityCheck: opts.skipIntegrityCheck,
        });
        return {
            packageFs,
            releaseFs,
            prefixPath: core_1.structUtils.getIdentVendorPath(locator),
            checksum,
        };
    }
    async fetchFromNetwork(locator, opts) {
        const sourceBuffer = await core_1.httpUtils.get(locator.reference, {
            configuration: opts.project.configuration,
        });
        return await core_1.tgzUtils.convertToZip(sourceBuffer, {
            compressionLevel: opts.project.configuration.get(`compressionLevel`),
            prefixPath: core_1.structUtils.getIdentVendorPath(locator),
            stripComponents: 1,
        });
    }
}
exports.TarballHttpFetcher = TarballHttpFetcher;
