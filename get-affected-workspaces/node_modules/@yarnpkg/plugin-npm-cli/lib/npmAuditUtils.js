"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDependencies = exports.getRequires = exports.getReportTree = exports.isError = exports.filterVulnerabilities = exports.getSeverityInclusions = exports.transformDescriptorIterableToRequiresObject = exports.getTransitiveDevDependencies = exports.allSeverities = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@yarnpkg/core");
const npmAuditTypes = tslib_1.__importStar(require("./npmAuditTypes"));
exports.allSeverities = [
    npmAuditTypes.Severity.Info,
    npmAuditTypes.Severity.Low,
    npmAuditTypes.Severity.Moderate,
    npmAuditTypes.Severity.High,
    npmAuditTypes.Severity.Critical,
];
// Enumerate all the transitive dependencies of a set of top-level packages
function getTransitiveDependencies(project, roots) {
    // Queue of dependency descriptorHashes to visit; set of already-visited patterns
    const queue = [];
    const descriptorHashes = new Set();
    const enqueue = (descriptorHash) => {
        if (descriptorHashes.has(descriptorHash))
            return;
        descriptorHashes.add(descriptorHash);
        queue.push(descriptorHash);
    };
    for (const root of roots)
        enqueue(root);
    // Final result set
    const transitiveDependencies = new Set();
    while (queue.length > 0) {
        const descriptorHash = queue.shift();
        const locatorHash = project.storedResolutions.get(descriptorHash);
        if (typeof locatorHash === `undefined`)
            throw new Error(`Assertion failed: Expected the resolution to have been registered`);
        const pkg = project.storedPackages.get(locatorHash);
        if (!pkg)
            continue;
        // Add the dependency to the result set
        transitiveDependencies.add(descriptorHash);
        // Enqueue any dependencies of the dependency for processing
        for (const dependency of pkg.dependencies.values()) {
            enqueue(dependency.descriptorHash);
        }
    }
    return transitiveDependencies;
}
function setDifference(x, y) {
    return new Set([...x].filter(value => !y.has(value)));
}
// Given a manifest, an optional workspace layout, and a lockfile, enumerate
// all package versions that:
// - are present in the lockfile
// - are a transitive dependency of some top-level devDependency
// - are not a transitive dependency of some top-level production dependency
function getTransitiveDevDependencies(project, workspace, { all }) {
    // Determine workspaces in scope
    const workspaces = all
        ? project.workspaces
        : [workspace];
    // Enumerate the top-level package manifest as well as any workspace manifests
    const manifests = workspaces.map(workspace => {
        return workspace.manifest;
    });
    // Collect all the top-level production and development dependencies across all manifests
    const productionDependencyIdentSet = new Set(manifests.map(manifest => [...manifest.dependencies].map(([identHash, descriptor]) => identHash)).flat());
    const developmentDependencyIdentSet = new Set(manifests.map(manifest => [...manifest.devDependencies].map(([identHash, descriptor]) => identHash)).flat());
    // Map workspace dependencies to descriptor hashes, filtered by the top-level production and development dependencies
    const workspaceDependencies = workspaces
        .map(workspace => [...workspace.dependencies.values()])
        .flat();
    const productionRoots = workspaceDependencies
        .filter(dependency => productionDependencyIdentSet.has(dependency.identHash))
        .map(dependency => dependency.descriptorHash);
    const developmentRoots = workspaceDependencies
        .filter(dependency => developmentDependencyIdentSet.has(dependency.identHash))
        .map(dependency => dependency.descriptorHash);
    // Enumerate all the transitive production and development dependencies
    const productionDependencies = getTransitiveDependencies(project, productionRoots);
    const developmentDependencies = getTransitiveDependencies(project, developmentRoots);
    // Exclude any development dependencies that are also production dependencies
    return setDifference(developmentDependencies, productionDependencies);
}
exports.getTransitiveDevDependencies = getTransitiveDevDependencies;
function transformDescriptorIterableToRequiresObject(descriptors) {
    const data = {};
    for (const descriptor of descriptors)
        data[core_1.structUtils.stringifyIdent(descriptor)] = core_1.structUtils.parseRange(descriptor.range).selector;
    return data;
}
exports.transformDescriptorIterableToRequiresObject = transformDescriptorIterableToRequiresObject;
function getSeverityInclusions(severity) {
    if (typeof severity === `undefined`)
        return new Set();
    const severityIndex = exports.allSeverities.indexOf(severity);
    const severities = exports.allSeverities.slice(severityIndex);
    return new Set(severities);
}
exports.getSeverityInclusions = getSeverityInclusions;
function filterVulnerabilities(vulnerabilities, severity) {
    const inclusions = getSeverityInclusions(severity);
    const filteredVulnerabilities = {};
    for (const key of inclusions)
        filteredVulnerabilities[key] = vulnerabilities[key];
    return filteredVulnerabilities;
}
exports.filterVulnerabilities = filterVulnerabilities;
function isError(vulnerabilities, severity) {
    var _a;
    const filteredVulnerabilities = filterVulnerabilities(vulnerabilities, severity);
    for (const key of Object.keys(filteredVulnerabilities))
        if ((_a = filteredVulnerabilities[key]) !== null && _a !== void 0 ? _a : 0 > 0)
            return true;
    return false;
}
exports.isError = isError;
function getReportTree(result, severity) {
    const auditTreeChildren = {};
    const auditTree = { children: auditTreeChildren };
    let advisories = Object.values(result.advisories);
    if (severity != null) {
        const inclusions = getSeverityInclusions(severity);
        advisories = advisories.filter(advisory => inclusions.has(advisory.severity));
    }
    for (const advisory of core_1.miscUtils.sortMap(advisories, advisory => advisory.module_name)) {
        auditTreeChildren[advisory.module_name] = {
            label: advisory.module_name,
            value: core_1.formatUtils.tuple(core_1.formatUtils.Type.RANGE, advisory.findings.map(finding => finding.version).join(`, `)),
            children: {
                Issue: {
                    label: `Issue`,
                    value: core_1.formatUtils.tuple(core_1.formatUtils.Type.NO_HINT, advisory.title),
                },
                URL: {
                    label: `URL`,
                    value: core_1.formatUtils.tuple(core_1.formatUtils.Type.URL, advisory.url),
                },
                Severity: {
                    label: `Severity`,
                    value: core_1.formatUtils.tuple(core_1.formatUtils.Type.NO_HINT, advisory.severity),
                },
                [`Vulnerable Versions`]: {
                    label: `Vulnerable Versions`,
                    value: core_1.formatUtils.tuple(core_1.formatUtils.Type.RANGE, advisory.vulnerable_versions),
                },
                [`Patched Versions`]: {
                    label: `Patched Versions`,
                    value: core_1.formatUtils.tuple(core_1.formatUtils.Type.RANGE, advisory.patched_versions),
                },
                Via: {
                    label: `Via`,
                    value: core_1.formatUtils.tuple(core_1.formatUtils.Type.NO_HINT, Array.from(new Set(advisory.findings.map(finding => finding.paths).flat().map(path => path.split(`>`)[0]))).join(`, `)),
                },
                Recommendation: {
                    label: `Recommendation`,
                    value: core_1.formatUtils.tuple(core_1.formatUtils.Type.NO_HINT, advisory.recommendation.replace(/\n/g, ` `)),
                },
            },
        };
    }
    return auditTree;
}
exports.getReportTree = getReportTree;
function getRequires(project, workspace, { all, environment }) {
    const workspaces = all
        ? project.workspaces
        : [workspace];
    const includeDependencies = [
        npmAuditTypes.Environment.All,
        npmAuditTypes.Environment.Production,
    ].includes(environment);
    const requiredDependencies = [];
    if (includeDependencies)
        for (const workspace of workspaces)
            for (const dependency of workspace.manifest.dependencies.values())
                requiredDependencies.push(dependency);
    const includeDevDependencies = [
        npmAuditTypes.Environment.All,
        npmAuditTypes.Environment.Development,
    ].includes(environment);
    const requiredDevDependencies = [];
    if (includeDevDependencies)
        for (const workspace of workspaces)
            for (const dependency of workspace.manifest.devDependencies.values())
                requiredDevDependencies.push(dependency);
    return transformDescriptorIterableToRequiresObject([
        ...requiredDependencies,
        ...requiredDevDependencies,
    ].filter(dependency => {
        return core_1.structUtils.parseRange(dependency.range).protocol === null;
    }));
}
exports.getRequires = getRequires;
function getDependencies(project, workspace, { all }) {
    var _a;
    const transitiveDevDependencies = getTransitiveDevDependencies(project, workspace, { all });
    const data = {};
    for (const pkg of project.storedPackages.values()) {
        data[core_1.structUtils.stringifyIdent(pkg)] = {
            version: (_a = pkg.version) !== null && _a !== void 0 ? _a : `0.0.0`,
            integrity: pkg.identHash,
            requires: transformDescriptorIterableToRequiresObject(pkg.dependencies.values()),
            dev: transitiveDevDependencies.has(core_1.structUtils.convertLocatorToDescriptor(pkg).descriptorHash),
        };
    }
    return data;
}
exports.getDependencies = getDependencies;
