"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const cli_1 = require("@yarnpkg/cli");
const core_1 = require("@yarnpkg/core");
const plugin_npm_1 = require("@yarnpkg/plugin-npm");
const plugin_pack_1 = require("@yarnpkg/plugin-pack");
const clipanion_1 = require("clipanion");
// eslint-disable-next-line arca/no-default-export
class NpmPublishCommand extends cli_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.tag = `latest`;
        this.tolerateRepublish = false;
    }
    async execute() {
        const configuration = await core_1.Configuration.find(this.context.cwd, this.context.plugins);
        const { project, workspace } = await core_1.Project.find(configuration, this.context.cwd);
        if (!workspace)
            throw new cli_1.WorkspaceRequiredError(project.cwd, this.context.cwd);
        if (workspace.manifest.private)
            throw new clipanion_1.UsageError(`Private workspaces cannot be published`);
        if (workspace.manifest.name === null || workspace.manifest.version === null)
            throw new clipanion_1.UsageError(`Workspaces must have valid names and versions to be published on an external registry`);
        await project.restoreInstallState();
        // We store it so that TS knows that it's non-null
        const ident = workspace.manifest.name;
        const version = workspace.manifest.version;
        const registry = plugin_npm_1.npmConfigUtils.getPublishRegistry(workspace.manifest, { configuration });
        const report = await core_1.StreamReport.start({
            configuration,
            stdout: this.context.stdout,
        }, async (report) => {
            // Not an error if --tolerate-republish is set
            if (this.tolerateRepublish) {
                try {
                    const registryData = await plugin_npm_1.npmHttpUtils.get(plugin_npm_1.npmHttpUtils.getIdentUrl(ident), {
                        configuration,
                        registry,
                        ident,
                        jsonResponse: true,
                    });
                    if (!Object.prototype.hasOwnProperty.call(registryData, `versions`))
                        throw new core_1.ReportError(core_1.MessageName.REMOTE_INVALID, `Registry returned invalid data for - missing "versions" field`);
                    if (Object.prototype.hasOwnProperty.call(registryData.versions, version)) {
                        report.reportWarning(core_1.MessageName.UNNAMED, `Registry already knows about version ${version}; skipping.`);
                        return;
                    }
                }
                catch (error) {
                    if (error.name !== `HTTPError`) {
                        throw error;
                    }
                    else if (error.response.statusCode !== 404) {
                        throw new core_1.ReportError(core_1.MessageName.NETWORK_ERROR, `The remote server answered with HTTP ${error.response.statusCode} ${error.response.statusMessage}`);
                    }
                }
            }
            await core_1.scriptUtils.maybeExecuteWorkspaceLifecycleScript(workspace, `prepublish`, { report });
            await plugin_pack_1.packUtils.prepareForPack(workspace, { report }, async () => {
                const files = await plugin_pack_1.packUtils.genPackList(workspace);
                for (const file of files)
                    report.reportInfo(null, file);
                const pack = await plugin_pack_1.packUtils.genPackStream(workspace, files);
                const buffer = await core_1.miscUtils.bufferStream(pack);
                const body = await plugin_npm_1.npmPublishUtils.makePublishBody(workspace, buffer, {
                    access: this.access,
                    tag: this.tag,
                    registry,
                });
                try {
                    await plugin_npm_1.npmHttpUtils.put(plugin_npm_1.npmHttpUtils.getIdentUrl(ident), body, {
                        configuration,
                        registry,
                        ident,
                        jsonResponse: true,
                    });
                }
                catch (error) {
                    if (error.name !== `HTTPError`) {
                        throw error;
                    }
                    else {
                        const message = error.response.body && error.response.body.error
                            ? error.response.body.error
                            : `The remote server answered with HTTP ${error.response.statusCode} ${error.response.statusMessage}`;
                        report.reportError(core_1.MessageName.NETWORK_ERROR, message);
                    }
                }
            });
            if (!report.hasErrors()) {
                report.reportInfo(core_1.MessageName.UNNAMED, `Package archive published`);
            }
        });
        return report.exitCode();
    }
}
NpmPublishCommand.usage = clipanion_1.Command.Usage({
    category: `Npm-related commands`,
    description: `publish the active workspace to the npm registry`,
    details: `
      This command will pack the active workspace into a fresh archive and upload it to the npm registry.

      The package will by default be attached to the \`latest\` tag on the registry, but this behavior can be overriden by using the \`--tag\` option.

      Note that for legacy reasons scoped packages are by default published with an access set to \`restricted\` (aka "private packages"). This requires you to register for a paid npm plan. In case you simply wish to publish a public scoped package to the registry (for free), just add the \`--access public\` flag. This behavior can be enabled by default through the \`npmPublishAccess\` settings.
    `,
    examples: [[
            `Publish the active workspace`,
            `yarn npm publish`,
        ]],
});
tslib_1.__decorate([
    clipanion_1.Command.String(`--access`, { description: `The access for the published package (public or restricted)` })
], NpmPublishCommand.prototype, "access", void 0);
tslib_1.__decorate([
    clipanion_1.Command.String(`--tag`, { description: `The tag on the registry that the package should be attached to` })
], NpmPublishCommand.prototype, "tag", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`--tolerate-republish`, { description: `Warn and exit when republishing an already existing version of a package` })
], NpmPublishCommand.prototype, "tolerateRepublish", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Path(`npm`, `publish`)
], NpmPublishCommand.prototype, "execute", null);
exports.default = NpmPublishCommand;
