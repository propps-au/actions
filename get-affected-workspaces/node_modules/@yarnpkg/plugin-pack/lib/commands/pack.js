"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const cli_1 = require("@yarnpkg/cli");
const core_1 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const clipanion_1 = require("clipanion");
const packUtils = tslib_1.__importStar(require("../packUtils"));
const outDescription = `Create the archive at the specified path`;
// eslint-disable-next-line arca/no-default-export
class PackCommand extends cli_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.installIfNeeded = false;
        this.dryRun = false;
        this.json = false;
    }
    async execute() {
        const configuration = await core_1.Configuration.find(this.context.cwd, this.context.plugins);
        const { project, workspace } = await core_1.Project.find(configuration, this.context.cwd);
        if (!workspace)
            throw new cli_1.WorkspaceRequiredError(project.cwd, this.context.cwd);
        if (await packUtils.hasPackScripts(workspace)) {
            if (this.installIfNeeded) {
                await project.install({
                    cache: await core_1.Cache.find(configuration),
                    report: new core_1.ThrowReport(),
                });
            }
            else {
                await project.restoreInstallState();
            }
        }
        const target = typeof this.out !== `undefined`
            ? fslib_1.ppath.resolve(this.context.cwd, interpolateOutputName(this.out, { workspace }))
            : fslib_1.ppath.resolve(workspace.cwd, `package.tgz`);
        const report = await core_1.StreamReport.start({
            configuration,
            stdout: this.context.stdout,
            json: this.json,
        }, async (report) => {
            await packUtils.prepareForPack(workspace, { report }, async () => {
                report.reportJson({ base: workspace.cwd });
                const files = await packUtils.genPackList(workspace);
                for (const file of files) {
                    report.reportInfo(null, file);
                    report.reportJson({ location: file });
                }
                if (!this.dryRun) {
                    const pack = await packUtils.genPackStream(workspace, files);
                    const write = fslib_1.xfs.createWriteStream(target);
                    pack.pipe(write);
                    await new Promise(resolve => {
                        write.on(`finish`, resolve);
                    });
                }
            });
            if (!this.dryRun) {
                report.reportInfo(core_1.MessageName.UNNAMED, `Package archive generated in ${core_1.formatUtils.pretty(configuration, target, core_1.formatUtils.Type.PATH)}`);
                report.reportJson({ output: target });
            }
        });
        return report.exitCode();
    }
}
PackCommand.usage = clipanion_1.Command.Usage({
    description: `generate a tarball from the active workspace`,
    details: `
      This command will turn the active workspace into a compressed archive suitable for publishing. The archive will by default be stored at the root of the workspace (\`package.tgz\`).

      If the \`-o,---out\` is set the archive will be created at the specified path. The \`%s\` and \`%v\` variables can be used within the path and will be respectively replaced by the package name and version.
    `,
    examples: [[
            `Create an archive from the active workspace`,
            `yarn pack`,
        ], [
            `List the files that would be made part of the workspace's archive`,
            `yarn pack --dry-run`,
        ], [
            `Name and output the archive in a dedicated folder`,
            `yarn pack --out /artifacts/%s-%v.tgz`,
        ]],
});
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`--install-if-needed`, { description: `Run a preliminary \`yarn install\` if the package contains build scripts` })
], PackCommand.prototype, "installIfNeeded", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`-n,--dry-run`, { description: `Print the file paths without actually generating the package archive` })
], PackCommand.prototype, "dryRun", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`--json`, { description: `Format the output as an NDJSON stream` })
], PackCommand.prototype, "json", void 0);
tslib_1.__decorate([
    clipanion_1.Command.String(`--filename`, { hidden: false, description: outDescription }),
    clipanion_1.Command.String(`-o,--out`, { description: outDescription })
], PackCommand.prototype, "out", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Path(`pack`)
], PackCommand.prototype, "execute", null);
exports.default = PackCommand;
function interpolateOutputName(name, { workspace }) {
    const interpolated = name
        .replace(`%s`, prettyWorkspaceIdent(workspace))
        .replace(`%v`, prettyWorkspaceVersion(workspace));
    return fslib_1.npath.toPortablePath(interpolated);
}
function prettyWorkspaceIdent(workspace) {
    if (workspace.manifest.name !== null) {
        return core_1.structUtils.slugifyIdent(workspace.manifest.name);
    }
    else {
        return `package`;
    }
}
function prettyWorkspaceVersion(workspace) {
    if (workspace.manifest.version !== null) {
        return workspace.manifest.version;
    }
    else {
        return `unknown`;
    }
}
