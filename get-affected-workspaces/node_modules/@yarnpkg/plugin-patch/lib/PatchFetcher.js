"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PatchFetcher = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@yarnpkg/core");
const core_2 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const libzip_1 = require("@yarnpkg/libzip");
const patchUtils = tslib_1.__importStar(require("./patchUtils"));
const UnmatchedHunkError_1 = require("./tools/UnmatchedHunkError");
const format_1 = require("./tools/format");
class PatchFetcher {
    supports(locator, opts) {
        if (!locator.reference.startsWith(`patch:`))
            return false;
        return true;
    }
    getLocalPath(locator, opts) {
        return null;
    }
    async fetch(locator, opts) {
        const expectedChecksum = opts.checksums.get(locator.locatorHash) || null;
        const [packageFs, releaseFs, checksum] = await opts.cache.fetchPackageFromCache(locator, expectedChecksum, {
            onHit: () => opts.report.reportCacheHit(locator),
            onMiss: () => opts.report.reportCacheMiss(locator, `${core_2.structUtils.prettyLocator(opts.project.configuration, locator)} can't be found in the cache and will be fetched from the disk`),
            loader: () => this.patchPackage(locator, opts),
            skipIntegrityCheck: opts.skipIntegrityCheck,
        });
        return {
            packageFs,
            releaseFs,
            prefixPath: core_2.structUtils.getIdentVendorPath(locator),
            localPath: this.getLocalPath(locator, opts),
            checksum,
        };
    }
    async patchPackage(locator, opts) {
        const { parentLocator, sourceLocator, sourceVersion, patchPaths } = patchUtils.parseLocator(locator);
        const patchFiles = await patchUtils.loadPatchFiles(parentLocator, patchPaths, opts);
        const tmpDir = await fslib_1.xfs.mktempPromise();
        const tmpFile = fslib_1.ppath.join(tmpDir, `patched.zip`);
        const sourceFetch = await opts.fetcher.fetch(sourceLocator, opts);
        const prefixPath = core_2.structUtils.getIdentVendorPath(locator);
        const libzip = await libzip_1.getLibzipPromise();
        const patchedPackage = new fslib_1.ZipFS(tmpFile, {
            libzip,
            create: true,
            level: opts.project.configuration.get(`compressionLevel`),
        });
        await patchedPackage.mkdirpPromise(prefixPath);
        await core_2.miscUtils.releaseAfterUseAsync(async () => {
            await patchedPackage.copyPromise(prefixPath, sourceFetch.prefixPath, { baseFs: sourceFetch.packageFs, stableSort: true });
        }, sourceFetch.releaseFs);
        const patchFs = new fslib_1.CwdFS(fslib_1.ppath.resolve(fslib_1.PortablePath.root, prefixPath), { baseFs: patchedPackage });
        for (const patchFile of patchFiles) {
            if (patchFile !== null) {
                try {
                    await patchUtils.applyPatchFile(patchUtils.parsePatchFile(patchFile), {
                        baseFs: patchFs,
                        version: sourceVersion,
                    });
                }
                catch (err) {
                    if (!(err instanceof UnmatchedHunkError_1.UnmatchedHunkError))
                        throw err;
                    const enableInlineHunks = opts.project.configuration.get(`enableInlineHunks`);
                    const suggestion = !enableInlineHunks
                        ? ` (set enableInlineHunks for details)`
                        : ``;
                    throw new core_1.ReportError(core_1.MessageName.PATCH_HUNK_FAILED, err.message + suggestion, report => {
                        if (!enableInlineHunks)
                            return;
                        format_1.reportHunk(err.hunk, {
                            configuration: opts.project.configuration,
                            report,
                        });
                    });
                }
            }
        }
        return patchedPackage;
    }
}
exports.PatchFetcher = PatchFetcher;
