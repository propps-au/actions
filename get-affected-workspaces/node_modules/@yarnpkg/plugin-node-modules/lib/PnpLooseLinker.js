"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PnpLooseLinker = void 0;
const core_1 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const libzip_1 = require("@yarnpkg/libzip");
const plugin_pnp_1 = require("@yarnpkg/plugin-pnp");
const pnpify_1 = require("@yarnpkg/pnpify");
const pnp_1 = require("@yarnpkg/pnp");
class PnpLooseLinker extends plugin_pnp_1.PnpLinker {
    constructor() {
        super(...arguments);
        this.mode = `loose`;
    }
    makeInstaller(opts) {
        return new PnpLooseInstaller(opts);
    }
}
exports.PnpLooseLinker = PnpLooseLinker;
class PnpLooseInstaller extends plugin_pnp_1.PnpInstaller {
    constructor() {
        super(...arguments);
        this.mode = `loose`;
    }
    async finalizeInstallWithPnp(pnpSettings) {
        if (this.opts.project.configuration.get(`pnpMode`) !== this.mode)
            return undefined;
        const defaultFsLayer = new fslib_1.VirtualFS({
            baseFs: new fslib_1.ZipOpenFS({
                libzip: await libzip_1.getLibzipPromise(),
                maxOpenFiles: 80,
                readOnlyArchives: true,
            }),
        });
        const pnp = pnp_1.makeRuntimeApi(pnpSettings, this.opts.project.cwd, defaultFsLayer);
        const nmTree = pnpify_1.buildNodeModulesTree(pnp, { pnpifyFs: false, project: this.opts.project });
        const fallbackPool = new Map();
        pnpSettings.fallbackPool = fallbackPool;
        const registerFallback = (name, entry) => {
            const locator = core_1.structUtils.parseLocator(entry.locator);
            const identStr = core_1.structUtils.stringifyIdent(locator);
            if (identStr === name) {
                fallbackPool.set(name, locator.reference);
            }
            else {
                fallbackPool.set(name, [identStr, locator.reference]);
            }
        };
        const root = fslib_1.ppath.join(this.opts.project.cwd, fslib_1.Filename.nodeModules);
        const entry = nmTree.get(root);
        if (typeof entry === `undefined`)
            throw new Error(`Assertion failed: Expected a root junction point`);
        if (`target` in entry)
            throw new Error(`Assertion failed: Expected the root junction point to be a directory`);
        for (const childName of entry.dirList) {
            const childP = fslib_1.ppath.join(root, childName);
            const child = nmTree.get(childP);
            if (typeof child === `undefined`)
                throw new Error(`Assertion failed: Expected the child to have been registered`);
            if (`target` in child) {
                registerFallback(childName, child);
            }
            else {
                for (const subChildName of child.dirList) {
                    const subChildP = fslib_1.ppath.join(childP, subChildName);
                    const subChild = nmTree.get(subChildP);
                    if (typeof subChild === `undefined`)
                        throw new Error(`Assertion failed: Expected the subchild to have been registered`);
                    if (`target` in subChild) {
                        registerFallback(`${childName}/${subChildName}`, subChild);
                    }
                    else {
                        throw new Error(`Assertion failed: Expected the leaf junction to be a package`);
                    }
                }
            }
        }
        return super.finalizeInstallWithPnp(pnpSettings);
    }
}
