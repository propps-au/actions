"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const cli_1 = require("@yarnpkg/cli");
const core_1 = require("@yarnpkg/core");
const core_2 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const clipanion_1 = require("clipanion");
const merge_1 = tslib_1.__importDefault(require("lodash/merge"));
const util_1 = require("util");
// eslint-disable-next-line arca/no-default-export
class InitCommand extends cli_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.usev2 = false;
        this.assumeFreshProject = false;
        this.yes = false;
        this.private = false;
        this.workspace = false;
        this.install = false;
    }
    async execute() {
        if (fslib_1.xfs.existsSync(fslib_1.ppath.join(this.context.cwd, core_1.Manifest.fileName)))
            throw new clipanion_1.UsageError(`A package.json already exists in the specified directory`);
        const configuration = await core_1.Configuration.find(this.context.cwd, this.context.plugins);
        const install = this.install
            ? this.install === true ? `latest` : this.install
            : null;
        if (install !== null) {
            return await this.executeProxy(configuration, install);
        }
        else {
            return await this.executeRegular(configuration);
        }
    }
    async executeProxy(configuration, version) {
        if (configuration.get(`yarnPath`) !== null)
            throw new clipanion_1.UsageError(`Cannot use the --install flag when the current directory already uses yarnPath (from ${configuration.sources.get(`yarnPath`)})`);
        if (configuration.projectCwd !== null)
            throw new clipanion_1.UsageError(`Cannot use the --install flag when the current directory is already part of a project`);
        if (!fslib_1.xfs.existsSync(this.context.cwd))
            await fslib_1.xfs.mkdirPromise(this.context.cwd, { recursive: true });
        const lockfilePath = fslib_1.ppath.join(this.context.cwd, configuration.get(`lockfileFilename`));
        if (!fslib_1.xfs.existsSync(lockfilePath))
            await fslib_1.xfs.writeFilePromise(lockfilePath, ``);
        const versionExitCode = await this.cli.run([`set`, `version`, version]);
        if (versionExitCode !== 0)
            return versionExitCode;
        this.context.stdout.write(`\n`);
        const args = [`--assume-fresh-project`];
        if (this.private)
            args.push(`-p`);
        if (this.workspace)
            args.push(`-w`);
        if (this.yes)
            args.push(`-y`);
        return await fslib_1.xfs.mktempPromise(async (binFolder) => {
            const { code } = await core_2.execUtils.pipevp(`yarn`, [`init`, ...args], {
                cwd: this.context.cwd,
                stdin: this.context.stdin,
                stdout: this.context.stdout,
                stderr: this.context.stderr,
                env: await core_2.scriptUtils.makeScriptEnv({ binFolder }),
            });
            return code;
        });
    }
    async executeRegular(configuration) {
        let existingProject = null;
        if (!this.assumeFreshProject) {
            try {
                existingProject = await core_1.Project.find(configuration, this.context.cwd);
            }
            catch (_a) {
                existingProject = null;
            }
        }
        if (!fslib_1.xfs.existsSync(this.context.cwd))
            await fslib_1.xfs.mkdirPromise(this.context.cwd, { recursive: true });
        const manifest = new core_1.Manifest();
        const fields = Object.fromEntries(configuration.get(`initFields`).entries());
        manifest.load(fields);
        manifest.name = core_2.structUtils.makeIdent(configuration.get(`initScope`), fslib_1.ppath.basename(this.context.cwd));
        manifest.version = configuration.get(`initVersion`);
        manifest.private = this.private || this.workspace;
        manifest.license = configuration.get(`initLicense`);
        if (this.workspace) {
            await fslib_1.xfs.mkdirPromise(fslib_1.ppath.join(this.context.cwd, `packages`), { recursive: true });
            manifest.workspaceDefinitions = [{
                    pattern: `packages/*`,
                }];
        }
        const serialized = {};
        manifest.exportTo(serialized);
        // @ts-expect-error: The Node typings forgot one field
        util_1.inspect.styles.name = `cyan`;
        this.context.stdout.write(`${util_1.inspect(serialized, {
            depth: Infinity,
            colors: true,
            compact: false,
        })}\n`);
        const manifestPath = fslib_1.ppath.join(this.context.cwd, core_1.Manifest.fileName);
        await fslib_1.xfs.changeFilePromise(manifestPath, `${JSON.stringify(serialized, null, 2)}\n`);
        const readmePath = fslib_1.ppath.join(this.context.cwd, `README.md`);
        if (!fslib_1.xfs.existsSync(readmePath))
            await fslib_1.xfs.writeFilePromise(readmePath, `# ${core_2.structUtils.stringifyIdent(manifest.name)}\n`);
        if (!existingProject) {
            const lockfilePath = fslib_1.ppath.join(this.context.cwd, fslib_1.Filename.lockfile);
            await fslib_1.xfs.writeFilePromise(lockfilePath, ``);
            const gitattributesLines = [
                `/.yarn/** linguist-vendored`,
            ];
            const gitattributesBody = gitattributesLines.map(line => {
                return `${line}\n`;
            }).join(``);
            const gitattributesPath = fslib_1.ppath.join(this.context.cwd, `.gitattributes`);
            if (!fslib_1.xfs.existsSync(gitattributesPath))
                await fslib_1.xfs.writeFilePromise(gitattributesPath, gitattributesBody);
            const gitignoreLines = [
                `/.yarn/*`,
                `!/.yarn/releases`,
                `!/.yarn/plugins`,
                `!/.yarn/sdks`,
                ``,
                `# Swap the comments on the following lines if you don't wish to use zero-installs`,
                `# Documentation here: https://yarnpkg.com/features/zero-installs`,
                `!/.yarn/cache`,
                `#/.pnp.*`,
            ];
            const gitignoreBody = gitignoreLines.map(line => {
                return `${line}\n`;
            }).join(``);
            const gitignorePath = fslib_1.ppath.join(this.context.cwd, `.gitignore`);
            if (!fslib_1.xfs.existsSync(gitignorePath))
                await fslib_1.xfs.writeFilePromise(gitignorePath, gitignoreBody);
            const editorConfigProperties = {
                [`*`]: {
                    endOfLine: `lf`,
                    insertFinalNewline: true,
                },
                [`*.{js,json,.yml}`]: {
                    charset: `utf-8`,
                    indentStyle: `space`,
                    indentSize: 2,
                },
            };
            merge_1.default(editorConfigProperties, configuration.get(`initEditorConfig`));
            let editorConfigBody = `root = true\n`;
            for (const [selector, props] of Object.entries(editorConfigProperties)) {
                editorConfigBody += `\n[${selector}]\n`;
                for (const [propName, propValue] of Object.entries(props)) {
                    const snakeCaseName = propName.replace(/[A-Z]/g, $0 => `_${$0.toLowerCase()}`);
                    editorConfigBody += `${snakeCaseName} = ${propValue}\n`;
                }
            }
            const editorConfigPath = fslib_1.ppath.join(this.context.cwd, `.editorconfig`);
            if (!fslib_1.xfs.existsSync(editorConfigPath))
                await fslib_1.xfs.writeFilePromise(editorConfigPath, editorConfigBody);
            await core_2.execUtils.execvp(`git`, [`init`], {
                cwd: this.context.cwd,
            });
        }
    }
}
InitCommand.usage = clipanion_1.Command.Usage({
    description: `create a new package`,
    details: `
      This command will setup a new package in your local directory.

      If the \`-p,--private\` or \`-w,--workspace\` options are set, the package will be private by default.

      If the \`-w,--workspace\` option is set, the package will be configured to accept a set of workspaces in the \`packages/\` directory.

      If the \`-i,--install\` option is given a value, Yarn will first download it using \`yarn set version\` and only then forward the init call to the newly downloaded bundle. Without arguments, the downloaded bundle will be \`latest\`.

      The initial settings of the manifest can be changed by using the \`initScope\` and \`initFields\` configuration values. Additionally, Yarn will generate an EditorConfig file whose rules can be altered via \`initEditorConfig\`, and will initialize a Git repository in the current directory.
    `,
    examples: [[
            `Create a new package in the local directory`,
            `yarn init`,
        ], [
            `Create a new private package in the local directory`,
            `yarn init -p`,
        ], [
            `Create a new package and store the Yarn release inside`,
            `yarn init -i latest`,
        ], [
            `Create a new private package and defines it as a workspace root`,
            `yarn init -w`,
        ]],
});
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`-2`, { hidden: true })
], InitCommand.prototype, "usev2", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`--assume-fresh-project`, { hidden: true })
], InitCommand.prototype, "assumeFreshProject", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`-y,--yes`, { hidden: true })
], InitCommand.prototype, "yes", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`-p,--private`, { description: `Initialize a private package` })
], InitCommand.prototype, "private", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`-w,--workspace`, { description: `Initialize a private workspace root with a \`packages/\` directory` })
], InitCommand.prototype, "workspace", void 0);
tslib_1.__decorate([
    clipanion_1.Command.String(`-i,--install`, { tolerateBoolean: true, description: `Initialize a package with a specific bundle that will be locked in the project` })
], InitCommand.prototype, "install", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Path(`init`)
], InitCommand.prototype, "execute", null);
exports.default = InitCommand;
