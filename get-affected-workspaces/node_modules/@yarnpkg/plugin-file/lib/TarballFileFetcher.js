"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TarballFileFetcher = void 0;
const core_1 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const constants_1 = require("./constants");
class TarballFileFetcher {
    supports(locator, opts) {
        if (!constants_1.TARBALL_REGEXP.test(locator.reference))
            return false;
        if (locator.reference.startsWith(constants_1.PROTOCOL))
            return true;
        return false;
    }
    getLocalPath(locator, opts) {
        return null;
    }
    async fetch(locator, opts) {
        const expectedChecksum = opts.checksums.get(locator.locatorHash) || null;
        const [packageFs, releaseFs, checksum] = await opts.cache.fetchPackageFromCache(locator, expectedChecksum, {
            onHit: () => opts.report.reportCacheHit(locator),
            onMiss: () => opts.report.reportCacheMiss(locator, `${core_1.structUtils.prettyLocator(opts.project.configuration, locator)} can't be found in the cache and will be fetched from the disk`),
            loader: () => this.fetchFromDisk(locator, opts),
            skipIntegrityCheck: opts.skipIntegrityCheck,
        });
        return {
            packageFs,
            releaseFs,
            prefixPath: core_1.structUtils.getIdentVendorPath(locator),
            checksum,
        };
    }
    async fetchFromDisk(locator, opts) {
        const { parentLocator, path } = core_1.structUtils.parseFileStyleRange(locator.reference, { protocol: constants_1.PROTOCOL });
        // If the file target is an absolute path we can directly access it via its
        // location on the disk. Otherwise we must go through the package fs.
        const parentFetch = fslib_1.ppath.isAbsolute(path)
            ? { packageFs: new fslib_1.CwdFS(fslib_1.PortablePath.root), prefixPath: fslib_1.PortablePath.dot, localPath: fslib_1.PortablePath.root }
            : await opts.fetcher.fetch(parentLocator, opts);
        // If the package fs publicized its "original location" (for example like
        // in the case of "file:" packages), we use it to derive the real location.
        const effectiveParentFetch = parentFetch.localPath
            ? { packageFs: new fslib_1.CwdFS(fslib_1.PortablePath.root), prefixPath: fslib_1.ppath.relative(fslib_1.PortablePath.root, parentFetch.localPath) }
            : parentFetch;
        // Discard the parent fs unless we really need it to access the files
        if (parentFetch !== effectiveParentFetch && parentFetch.releaseFs)
            parentFetch.releaseFs();
        const sourceFs = effectiveParentFetch.packageFs;
        const sourcePath = fslib_1.ppath.join(effectiveParentFetch.prefixPath, path);
        const sourceBuffer = await sourceFs.readFilePromise(sourcePath);
        return await core_1.miscUtils.releaseAfterUseAsync(async () => {
            return await core_1.tgzUtils.convertToZip(sourceBuffer, {
                compressionLevel: opts.project.configuration.get(`compressionLevel`),
                prefixPath: core_1.structUtils.getIdentVendorPath(locator),
                stripComponents: 1,
            });
        }, effectiveParentFetch.releaseFs);
    }
}
exports.TarballFileFetcher = TarballFileFetcher;
