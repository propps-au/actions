"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileFetcher = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const constants_1 = require("./constants");
const fileUtils = tslib_1.__importStar(require("./fileUtils"));
class FileFetcher {
    supports(locator, opts) {
        if (!locator.reference.startsWith(constants_1.PROTOCOL))
            return false;
        return true;
    }
    getLocalPath(locator, opts) {
        const { parentLocator, path } = core_1.structUtils.parseFileStyleRange(locator.reference, { protocol: constants_1.PROTOCOL });
        if (fslib_1.ppath.isAbsolute(path))
            return path;
        const parentLocalPath = opts.fetcher.getLocalPath(parentLocator, opts);
        if (parentLocalPath === null)
            return null;
        return fslib_1.ppath.resolve(parentLocalPath, path);
    }
    async fetch(locator, opts) {
        const expectedChecksum = opts.checksums.get(locator.locatorHash) || null;
        const [packageFs, releaseFs, checksum] = await opts.cache.fetchPackageFromCache(locator, expectedChecksum, {
            onHit: () => opts.report.reportCacheHit(locator),
            onMiss: () => opts.report.reportCacheMiss(locator, `${core_1.structUtils.prettyLocator(opts.project.configuration, locator)} can't be found in the cache and will be fetched from the disk`),
            loader: () => this.fetchFromDisk(locator, opts),
            skipIntegrityCheck: opts.skipIntegrityCheck,
        });
        return {
            packageFs,
            releaseFs,
            prefixPath: core_1.structUtils.getIdentVendorPath(locator),
            localPath: this.getLocalPath(locator, opts),
            checksum,
        };
    }
    async fetchFromDisk(locator, opts) {
        return fileUtils.makeArchiveFromLocator(locator, { protocol: constants_1.PROTOCOL, fetchOptions: opts });
    }
}
exports.FileFetcher = FileFetcher;
