"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.invalidGithubUrlMessage = exports.parseGithubUrl = exports.isGithubUrl = void 0;
const tslib_1 = require("tslib");
const querystring_1 = tslib_1.__importDefault(require("querystring"));
const githubPatterns = [
    /^https?:\/\/(?:([^/]+?)@)?github.com\/([^/#]+)\/([^/#]+)\/tarball\/([^/#]+)(?:#(.*))?$/,
    /^https?:\/\/(?:([^/]+?)@)?github.com\/([^/#]+)\/([^/#]+?)(?:\.git)?(?:#(.*))?$/,
];
/**
 * Determines whether a given url is a valid github git url via regex
 */
function isGithubUrl(url) {
    return url ? githubPatterns.some(pattern => !!url.match(pattern)) : false;
}
exports.isGithubUrl = isGithubUrl;
/**
 * Takes a valid github repository url and parses it, returning
 * an object of type `ParsedGithubUrl`
 */
function parseGithubUrl(urlStr) {
    let match;
    for (const pattern of githubPatterns) {
        match = urlStr.match(pattern);
        if (match) {
            break;
        }
    }
    if (!match)
        throw new Error(invalidGithubUrlMessage(urlStr));
    let [, auth, username, reponame, treeish = `master`] = match;
    const { commit } = querystring_1.default.parse(treeish);
    treeish =
        // New style:
        // The URLs have already been normalized by `gitUtils.resolveUrl`,
        // so it's certain in the context of the `GithubFetcher`
        // that the `commit` querystring parameter exists
        commit
            // Old style:
            // Shouldn't ever be needed by the GithubFetcher
            || treeish.replace(/[^:]*:/, ``);
    return { auth, username, reponame, treeish };
}
exports.parseGithubUrl = parseGithubUrl;
function invalidGithubUrlMessage(url) {
    return `Input cannot be parsed as a valid GitHub URL ('${url}').`;
}
exports.invalidGithubUrlMessage = invalidGithubUrlMessage;
