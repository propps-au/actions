"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const cli_1 = require("@yarnpkg/cli");
const core_1 = require("@yarnpkg/core");
const core_2 = require("@yarnpkg/core");
const core_3 = require("@yarnpkg/core");
const clipanion_1 = require("clipanion");
const micromatch_1 = tslib_1.__importDefault(require("micromatch"));
const suggestUtils = tslib_1.__importStar(require("../suggestUtils"));
// eslint-disable-next-line arca/no-default-export
class RemoveCommand extends cli_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.all = false;
        this.patterns = [];
    }
    async execute() {
        const configuration = await core_1.Configuration.find(this.context.cwd, this.context.plugins);
        const { project, workspace } = await core_1.Project.find(configuration, this.context.cwd);
        const cache = await core_1.Cache.find(configuration);
        if (!workspace)
            throw new cli_1.WorkspaceRequiredError(project.cwd, this.context.cwd);
        await project.restoreInstallState({
            restoreResolutions: false,
        });
        const affectedWorkspaces = this.all
            ? project.workspaces
            : [workspace];
        const targets = [
            suggestUtils.Target.REGULAR,
            suggestUtils.Target.DEVELOPMENT,
            suggestUtils.Target.PEER,
        ];
        const unreferencedPatterns = [];
        let hasChanged = false;
        const afterWorkspaceDependencyRemovalList = [];
        for (const pattern of this.patterns) {
            let isReferenced = false;
            // This isn't really needed - It's just for consistency:
            // All patterns are either valid or not for all commands (e.g. remove, up)
            const pseudoIdent = core_3.structUtils.parseIdent(pattern);
            for (const workspace of affectedWorkspaces) {
                const peerDependenciesMeta = [...workspace.manifest.peerDependenciesMeta.keys()];
                for (const stringifiedIdent of micromatch_1.default(peerDependenciesMeta, pattern)) {
                    workspace.manifest.peerDependenciesMeta.delete(stringifiedIdent);
                    hasChanged = true;
                    isReferenced = true;
                }
                for (const target of targets) {
                    const descriptors = workspace.manifest.getForScope(target);
                    const stringifiedIdents = [...descriptors.values()].map(descriptor => {
                        return core_3.structUtils.stringifyIdent(descriptor);
                    });
                    for (const stringifiedIdent of micromatch_1.default(stringifiedIdents, core_3.structUtils.stringifyIdent(pseudoIdent))) {
                        const { identHash } = core_3.structUtils.parseIdent(stringifiedIdent);
                        const removedDescriptor = descriptors.get(identHash);
                        if (typeof removedDescriptor === `undefined`)
                            throw new Error(`Assertion failed: Expected the descriptor to be registered`);
                        workspace.manifest[target].delete(identHash);
                        afterWorkspaceDependencyRemovalList.push([
                            workspace,
                            target,
                            removedDescriptor,
                        ]);
                        hasChanged = true;
                        isReferenced = true;
                    }
                }
            }
            if (!isReferenced) {
                unreferencedPatterns.push(pattern);
            }
        }
        const patterns = unreferencedPatterns.length > 1
            ? `Patterns`
            : `Pattern`;
        const dont = unreferencedPatterns.length > 1
            ? `don't`
            : `doesn't`;
        const which = this.all
            ? `any`
            : `this`;
        if (unreferencedPatterns.length > 0)
            throw new clipanion_1.UsageError(`${patterns} ${core_1.formatUtils.prettyList(configuration, unreferencedPatterns, core_1.FormatType.CODE)} ${dont} match any packages referenced by ${which} workspace`);
        if (hasChanged) {
            await configuration.triggerMultipleHooks((hooks) => hooks.afterWorkspaceDependencyRemoval, afterWorkspaceDependencyRemovalList);
            const report = await core_2.StreamReport.start({
                configuration,
                stdout: this.context.stdout,
            }, async (report) => {
                await project.install({ cache, report });
            });
            return report.exitCode();
        }
        return 0;
    }
}
RemoveCommand.usage = clipanion_1.Command.Usage({
    description: `remove dependencies from the project`,
    details: `
      This command will remove the packages matching the specified patterns from the current workspace.

      This command accepts glob patterns as arguments (if valid Idents and supported by [micromatch](https://github.com/micromatch/micromatch)). Make sure to escape the patterns, to prevent your own shell from trying to expand them.
    `,
    examples: [[
            `Remove a dependency from the current project`,
            `$0 remove lodash`,
        ], [
            `Remove a dependency from all workspaces at once`,
            `$0 remove lodash --all`,
        ], [
            `Remove all dependencies starting with \`eslint-\``,
            `$0 remove 'eslint-*'`,
        ], [
            `Remove all dependencies with the \`@babel\` scope`,
            `$0 remove '@babel/*'`,
        ], [
            `Remove all dependencies matching \`react-dom\` or \`react-helmet\``,
            `$0 remove 'react-{dom,helmet}'`,
        ]],
});
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`-A,--all`, { description: `Apply the operation to all workspaces from the current project` })
], RemoveCommand.prototype, "all", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Rest()
], RemoveCommand.prototype, "patterns", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Path(`remove`)
], RemoveCommand.prototype, "execute", null);
exports.default = RemoveCommand;
