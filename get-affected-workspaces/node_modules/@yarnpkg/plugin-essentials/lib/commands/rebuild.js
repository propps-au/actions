"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const cli_1 = require("@yarnpkg/cli");
const core_1 = require("@yarnpkg/core");
const core_2 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const parsers_1 = require("@yarnpkg/parsers");
const clipanion_1 = require("clipanion");
// eslint-disable-next-line arca/no-default-export
class RunCommand extends cli_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.idents = [];
    }
    async execute() {
        const configuration = await core_1.Configuration.find(this.context.cwd, this.context.plugins);
        const { project, workspace } = await core_2.Project.find(configuration, this.context.cwd);
        const cache = await core_1.Cache.find(configuration);
        if (!workspace)
            throw new cli_1.WorkspaceRequiredError(project.cwd, this.context.cwd);
        const filteredIdents = new Set();
        for (const identStr of this.idents)
            filteredIdents.add(core_2.structUtils.parseIdent(identStr).identHash);
        await project.resolveEverything({
            cache,
            report: new core_2.ThrowReport(),
        });
        const bstatePath = configuration.get(`bstatePath`);
        const bstate = fslib_1.xfs.existsSync(bstatePath)
            ? parsers_1.parseSyml(await fslib_1.xfs.readFilePromise(bstatePath, `utf8`))
            : {};
        const nextBState = new Map();
        for (const pkg of project.storedPackages.values()) {
            if (!Object.prototype.hasOwnProperty.call(bstate, pkg.locatorHash))
                continue;
            if (filteredIdents.size === 0 || filteredIdents.has(pkg.identHash))
                continue;
            const buildHash = bstate[pkg.locatorHash];
            nextBState.set(pkg.locatorHash, buildHash);
        }
        if (nextBState.size > 0) {
            const bstatePath = configuration.get(`bstatePath`);
            const bstateFile = core_2.Project.generateBuildStateFile(nextBState, project.storedPackages);
            await fslib_1.xfs.mkdirPromise(fslib_1.ppath.dirname(bstatePath), { recursive: true });
            await fslib_1.xfs.changeFilePromise(bstatePath, bstateFile, {
                automaticNewlines: true,
            });
        }
        else {
            await fslib_1.xfs.removePromise(bstatePath);
        }
        const installReport = await core_1.StreamReport.start({
            configuration,
            stdout: this.context.stdout,
            includeLogs: !this.context.quiet,
        }, async (report) => {
            await project.install({ cache, report });
        });
        return installReport.exitCode();
    }
}
RunCommand.usage = clipanion_1.Command.Usage({
    description: `rebuild the project's native packages`,
    details: `
      This command will automatically cause Yarn to forget about previous compilations of the given packages and to run them again.

      Note that while Yarn forgets the compilation, the previous artifacts aren't erased from the filesystem and may affect the next builds (in good or bad). To avoid this, you may remove the .yarn/unplugged folder, or any other relevant location where packages might have been stored (Yarn may offer a way to do that automatically in the future).

      By default all packages will be rebuilt, but you can filter the list by specifying the names of the packages you want to clear from memory.
    `,
    examples: [[
            `Rebuild all packages`,
            `$0 rebuild`,
        ], [
            `Rebuild fsevents only`,
            `$0 rebuild fsevents`,
        ]],
});
tslib_1.__decorate([
    clipanion_1.Command.Rest()
], RunCommand.prototype, "idents", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Path(`rebuild`)
], RunCommand.prototype, "execute", null);
exports.default = RunCommand;
