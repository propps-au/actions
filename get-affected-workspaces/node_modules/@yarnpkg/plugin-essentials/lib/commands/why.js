"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const cli_1 = require("@yarnpkg/cli");
const core_1 = require("@yarnpkg/core");
const core_2 = require("@yarnpkg/core");
const core_3 = require("@yarnpkg/core");
const clipanion_1 = require("clipanion");
// eslint-disable-next-line arca/no-default-export
class WhyCommand extends cli_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.recursive = false;
        this.json = false;
        this.peers = false;
    }
    async execute() {
        const configuration = await core_1.Configuration.find(this.context.cwd, this.context.plugins);
        const { project, workspace } = await core_2.Project.find(configuration, this.context.cwd);
        if (!workspace)
            throw new cli_1.WorkspaceRequiredError(project.cwd, this.context.cwd);
        await project.restoreInstallState();
        const identHash = core_3.structUtils.parseIdent(this.package).identHash;
        const whyTree = this.recursive
            ? whyRecursive(project, identHash, { configuration, peers: this.peers })
            : whySimple(project, identHash, { configuration, peers: this.peers });
        core_3.treeUtils.emitTree(whyTree, {
            configuration,
            stdout: this.context.stdout,
            json: this.json,
            separators: 1,
        });
    }
}
WhyCommand.usage = clipanion_1.Command.Usage({
    description: `display the reason why a package is needed`,
    details: `
      This command prints the exact reasons why a package appears in the dependency tree.

      If \`-R,--recursive\` is set, the listing will go in depth and will list, for each workspaces, what are all the paths that lead to the dependency. Note that the display is somewhat optimized in that it will not print the package listing twice for a single package, so if you see a leaf named "Foo" when looking for "Bar", it means that "Foo" already got printed higher in the tree.
    `,
    examples: [[
            `Explain why lodash is used in your project`,
            `$0 why lodash`,
        ]],
});
tslib_1.__decorate([
    clipanion_1.Command.String()
], WhyCommand.prototype, "package", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`-R,--recursive`, { description: `List, for each workspace, what are all the paths that lead to the dependency` })
], WhyCommand.prototype, "recursive", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`--json`, { description: `Format the output as an NDJSON stream` })
], WhyCommand.prototype, "json", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`--peers`, { description: `Also print the peer dependencies that match the specified name` })
], WhyCommand.prototype, "peers", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Path(`why`)
], WhyCommand.prototype, "execute", null);
exports.default = WhyCommand;
function whySimple(project, identHash, { configuration, peers }) {
    const sortedPackages = core_3.miscUtils.sortMap(project.storedPackages.values(), pkg => {
        return core_3.structUtils.stringifyLocator(pkg);
    });
    const rootChildren = {};
    const root = { children: rootChildren };
    for (const pkg of sortedPackages) {
        const nodeChildren = {};
        const node = null;
        for (const dependency of pkg.dependencies.values()) {
            if (!peers && pkg.peerDependencies.has(dependency.identHash))
                continue;
            const resolution = project.storedResolutions.get(dependency.descriptorHash);
            if (!resolution)
                throw new Error(`Assertion failed: The resolution should have been registered`);
            const nextPkg = project.storedPackages.get(resolution);
            if (!nextPkg)
                throw new Error(`Assertion failed: The package should have been registered`);
            if (nextPkg.identHash !== identHash)
                continue;
            if (node === null) {
                const key = core_3.structUtils.stringifyLocator(pkg);
                rootChildren[key] = { value: [pkg, core_1.formatUtils.Type.LOCATOR], children: nodeChildren };
            }
            const key = core_3.structUtils.stringifyLocator(nextPkg);
            nodeChildren[key] = { value: [{
                        descriptor: dependency,
                        locator: nextPkg,
                    }, core_1.formatUtils.Type.DEPENDENT] };
        }
    }
    return root;
}
function whyRecursive(project, identHash, { configuration, peers }) {
    const sortedWorkspaces = core_3.miscUtils.sortMap(project.workspaces, workspace => {
        return core_3.structUtils.stringifyLocator(workspace.anchoredLocator);
    });
    const seen = new Set();
    const dependents = new Set();
    const markAllDependents = (pkg) => {
        if (seen.has(pkg.locatorHash))
            return dependents.has(pkg.locatorHash);
        seen.add(pkg.locatorHash);
        if (pkg.identHash === identHash) {
            dependents.add(pkg.locatorHash);
            return true;
        }
        let depends = false;
        if (pkg.identHash === identHash)
            depends = true;
        for (const dependency of pkg.dependencies.values()) {
            if (!peers && pkg.peerDependencies.has(dependency.identHash))
                continue;
            const resolution = project.storedResolutions.get(dependency.descriptorHash);
            if (!resolution)
                throw new Error(`Assertion failed: The resolution should have been registered`);
            const nextPkg = project.storedPackages.get(resolution);
            if (!nextPkg)
                throw new Error(`Assertion failed: The package should have been registered`);
            if (markAllDependents(nextPkg)) {
                depends = true;
            }
        }
        if (depends)
            dependents.add(pkg.locatorHash);
        return depends;
    };
    for (const workspace of sortedWorkspaces) {
        const pkg = project.storedPackages.get(workspace.anchoredLocator.locatorHash);
        if (!pkg)
            throw new Error(`Assertion failed: The package should have been registered`);
        markAllDependents(pkg);
    }
    const printed = new Set();
    const rootChildren = {};
    const root = { children: rootChildren };
    const printAllDependents = (pkg, parentChildren, dependency) => {
        if (!dependents.has(pkg.locatorHash))
            return;
        const nodeValue = dependency !== null
            ? core_1.formatUtils.tuple(core_1.formatUtils.Type.DEPENDENT, { locator: pkg, descriptor: dependency })
            : core_1.formatUtils.tuple(core_1.formatUtils.Type.LOCATOR, pkg);
        const nodeChildren = {};
        const node = {
            value: nodeValue,
            children: nodeChildren,
        };
        const key = core_3.structUtils.stringifyLocator(pkg);
        parentChildren[key] = node;
        // We don't want to reprint the children for a package that already got
        // printed as part of another branch
        if (printed.has(pkg.locatorHash))
            return;
        printed.add(pkg.locatorHash);
        // We don't want to print the children of our transitive workspace
        // dependencies, as they will be printed in their own top-level branch
        if (dependency !== null && project.tryWorkspaceByLocator(pkg))
            return;
        for (const dependency of pkg.dependencies.values()) {
            if (!peers && pkg.peerDependencies.has(dependency.identHash))
                continue;
            const resolution = project.storedResolutions.get(dependency.descriptorHash);
            if (!resolution)
                throw new Error(`Assertion failed: The resolution should have been registered`);
            const nextPkg = project.storedPackages.get(resolution);
            if (!nextPkg)
                throw new Error(`Assertion failed: The package should have been registered`);
            printAllDependents(nextPkg, nodeChildren, dependency);
        }
    };
    for (const workspace of sortedWorkspaces) {
        const pkg = project.storedPackages.get(workspace.anchoredLocator.locatorHash);
        if (!pkg)
            throw new Error(`Assertion failed: The package should have been registered`);
        printAllDependents(pkg, rootChildren, null);
    }
    return root;
}
