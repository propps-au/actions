"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const cli_1 = require("@yarnpkg/cli");
const core_1 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const clipanion_1 = require("clipanion");
const micromatch_1 = tslib_1.__importDefault(require("micromatch"));
// eslint-disable-next-line arca/no-default-export
class InfoCommand extends cli_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.all = false;
        this.recursive = false;
        this.extra = [];
        this.cache = false;
        this.dependents = false;
        this.manifest = false;
        this.nameOnly = false;
        this.virtuals = false;
        this.json = false;
        this.patterns = [];
    }
    async execute() {
        const configuration = await core_1.Configuration.find(this.context.cwd, this.context.plugins);
        const { project, workspace } = await core_1.Project.find(configuration, this.context.cwd);
        const cache = await core_1.Cache.find(configuration);
        if (!workspace && !this.all)
            throw new cli_1.WorkspaceRequiredError(project.cwd, this.context.cwd);
        await project.restoreInstallState();
        const extraSet = new Set(this.extra);
        if (this.cache)
            extraSet.add(`cache`);
        if (this.dependents)
            extraSet.add(`dependents`);
        if (this.manifest)
            extraSet.add(`manifest`);
        const traverseWorkspace = (workspace, { recursive }) => {
            const initialHash = workspace.anchoredLocator.locatorHash;
            const seen = new Map();
            const pass = [initialHash];
            while (pass.length > 0) {
                const hash = pass.shift();
                if (seen.has(hash))
                    continue;
                const pkg = project.storedPackages.get(hash);
                if (typeof pkg === `undefined`)
                    throw new Error(`Assertion failed: Expected the package to be registered`);
                seen.set(hash, pkg);
                if (core_1.structUtils.isVirtualLocator(pkg))
                    pass.push(core_1.structUtils.devirtualizeLocator(pkg).locatorHash);
                if (!recursive && hash !== initialHash)
                    continue;
                for (const dependency of pkg.dependencies.values()) {
                    const resolution = project.storedResolutions.get(dependency.descriptorHash);
                    if (typeof resolution === `undefined`)
                        throw new Error(`Assertion failed: Expected the resolution to be registered`);
                    pass.push(resolution);
                }
            }
            return seen.values();
        };
        const traverseAllWorkspaces = ({ recursive }) => {
            const aggregate = new Map();
            for (const workspace of project.workspaces)
                for (const pkg of traverseWorkspace(workspace, { recursive }))
                    aggregate.set(pkg.locatorHash, pkg);
            return aggregate.values();
        };
        const getLookupSet = ({ all, recursive }) => {
            // Optimization: if both -A and -R are set, it means we care about the
            // whole set of packages, no need for filtering
            if (all && recursive)
                return project.storedPackages.values();
            if (all) {
                return traverseAllWorkspaces({ recursive });
            }
            else {
                return traverseWorkspace(workspace, { recursive });
            }
        };
        const findSelectedSet = ({ all, recursive }) => {
            const lookupSet = getLookupSet({ all, recursive });
            const matchers = this.patterns.map(pattern => {
                const patternLocator = core_1.structUtils.parseLocator(pattern);
                const identRegex = micromatch_1.default.makeRe(core_1.structUtils.stringifyIdent(patternLocator));
                const patternIsVirtual = core_1.structUtils.isVirtualLocator(patternLocator);
                const uvPatternLocator = patternIsVirtual
                    ? core_1.structUtils.devirtualizeLocator(patternLocator)
                    : patternLocator;
                return (pkg) => {
                    const stringifiedIdent = core_1.structUtils.stringifyIdent(pkg);
                    if (!identRegex.test(stringifiedIdent))
                        return false;
                    if (patternLocator.reference === `unknown`)
                        return true;
                    const pkgIsVirtual = core_1.structUtils.isVirtualLocator(pkg);
                    const uvPkgLocator = pkgIsVirtual
                        ? core_1.structUtils.devirtualizeLocator(pkg)
                        : pkg;
                    // If the pattern is explicitly virtual, we only accept this one virtual package, never the others
                    if (patternIsVirtual && pkgIsVirtual && patternLocator.reference !== pkg.reference)
                        return false;
                    // We only accept that belong to the current reference (or its base if it's a virtual package)
                    if (uvPatternLocator.reference !== uvPkgLocator.reference)
                        return false;
                    return true;
                };
            });
            const sortedLookup = core_1.miscUtils.sortMap([...lookupSet], pkg => {
                return core_1.structUtils.stringifyLocator(pkg);
            });
            const selection = sortedLookup.filter(pkg => {
                return matchers.length === 0 || matchers.some(matcher => matcher(pkg));
            });
            return { selection, sortedLookup };
        };
        const { selection, sortedLookup } = findSelectedSet({
            all: this.all,
            recursive: this.recursive,
        });
        if (selection.length === 0)
            throw new clipanion_1.UsageError(`No package matched your request`);
        const dependentMap = new Map();
        if (this.dependents) {
            for (const pkg of sortedLookup) {
                for (const dependency of pkg.dependencies.values()) {
                    const resolution = project.storedResolutions.get(dependency.descriptorHash);
                    if (typeof resolution === `undefined`)
                        throw new Error(`Assertion failed: Expected the resolution to be registered`);
                    core_1.miscUtils.getArrayWithDefault(dependentMap, resolution).push(pkg);
                }
            }
        }
        const allInstances = new Map();
        for (const pkg of sortedLookup) {
            if (!core_1.structUtils.isVirtualLocator(pkg))
                continue;
            const base = core_1.structUtils.devirtualizeLocator(pkg);
            core_1.miscUtils.getArrayWithDefault(allInstances, base.locatorHash).push(pkg);
        }
        const infoTreeChildren = {};
        const infoTree = { children: infoTreeChildren };
        const fetcher = configuration.makeFetcher();
        const fetcherOptions = { project, fetcher, cache, checksums: project.storedChecksums, report: new core_1.ThrowReport(), skipIntegrityCheck: true };
        const builtinInfoBuilders = [
            // Manifest fields
            async (pkg, extra, registerData) => {
                var _a, _b;
                if (!extra.has(`manifest`))
                    return;
                const fetchResult = await fetcher.fetch(pkg, fetcherOptions);
                let manifest;
                try {
                    manifest = await core_1.Manifest.find(fetchResult.prefixPath, { baseFs: fetchResult.packageFs });
                }
                finally {
                    (_a = fetchResult.releaseFs) === null || _a === void 0 ? void 0 : _a.call(fetchResult);
                }
                registerData(`Manifest`, {
                    [`License`]: core_1.formatUtils.tuple(core_1.formatUtils.Type.NO_HINT, manifest.license),
                    [`Homepage`]: core_1.formatUtils.tuple(core_1.formatUtils.Type.URL, (_b = manifest.raw.homepage) !== null && _b !== void 0 ? _b : null),
                });
            },
            // Cache info
            async (pkg, extra, registerData) => {
                var _a;
                if (!extra.has(`cache`))
                    return;
                const checksum = (_a = project.storedChecksums.get(pkg.locatorHash)) !== null && _a !== void 0 ? _a : null;
                const cachePath = cache.getLocatorPath(pkg, checksum);
                let stat;
                if (cachePath !== null) {
                    try {
                        stat = fslib_1.xfs.statSync(cachePath);
                    }
                    catch (_b) { }
                }
                const size = typeof stat !== `undefined`
                    ? [stat.size, core_1.formatUtils.Type.SIZE]
                    : undefined;
                registerData(`Cache`, {
                    [`Checksum`]: core_1.formatUtils.tuple(core_1.formatUtils.Type.NO_HINT, checksum),
                    [`Path`]: core_1.formatUtils.tuple(core_1.formatUtils.Type.PATH, cachePath),
                    [`Size`]: size,
                });
            },
        ];
        for (const pkg of selection) {
            const isVirtual = core_1.structUtils.isVirtualLocator(pkg);
            if (!this.virtuals && isVirtual)
                continue;
            const nodeChildren = {};
            const node = {
                value: [pkg, core_1.formatUtils.Type.LOCATOR],
                children: nodeChildren,
            };
            infoTreeChildren[core_1.structUtils.stringifyLocator(pkg)] = node;
            if (this.nameOnly) {
                delete node.children;
                continue;
            }
            const instances = allInstances.get(pkg.locatorHash);
            if (typeof instances !== `undefined`) {
                nodeChildren.Instances = {
                    label: `Instances`,
                    value: core_1.formatUtils.tuple(core_1.formatUtils.Type.NUMBER, instances.length),
                };
            }
            nodeChildren.Version = {
                label: `Version`,
                value: core_1.formatUtils.tuple(core_1.formatUtils.Type.NO_HINT, pkg.version),
            };
            const registerData = (namespace, info) => {
                const namespaceNode = {};
                nodeChildren[namespace] = namespaceNode;
                if (Array.isArray(info)) {
                    namespaceNode.children = info.map(value => ({ value }));
                }
                else {
                    const namespaceChildren = {};
                    namespaceNode.children = namespaceChildren;
                    for (const [key, value] of Object.entries(info)) {
                        if (typeof value === `undefined`)
                            continue;
                        namespaceChildren[key] = {
                            label: key,
                            value,
                        };
                    }
                }
            };
            if (!isVirtual) {
                for (const infoBuilder of builtinInfoBuilders)
                    await infoBuilder(pkg, extraSet, registerData);
                await configuration.triggerHook((hooks) => {
                    return hooks.fetchPackageInfo;
                }, pkg, extraSet, registerData);
            }
            if (pkg.bin.size > 0 && !isVirtual) {
                registerData(`Exported Binaries`, [...pkg.bin.keys()].map(name => {
                    return core_1.formatUtils.tuple(core_1.formatUtils.Type.PATH, name);
                }));
            }
            const dependents = dependentMap.get(pkg.locatorHash);
            if (typeof dependents !== `undefined` && dependents.length > 0) {
                registerData(`Dependents`, dependents.map(dependent => {
                    return core_1.formatUtils.tuple(core_1.formatUtils.Type.LOCATOR, dependent);
                }));
            }
            if (pkg.dependencies.size > 0 && !isVirtual) {
                registerData(`Dependencies`, [...pkg.dependencies.values()].map(dependency => {
                    var _a;
                    const resolutionHash = project.storedResolutions.get(dependency.descriptorHash);
                    const resolution = typeof resolutionHash !== `undefined`
                        ? (_a = project.storedPackages.get(resolutionHash)) !== null && _a !== void 0 ? _a : null : null;
                    return core_1.formatUtils.tuple(core_1.formatUtils.Type.RESOLUTION, {
                        descriptor: dependency,
                        locator: resolution,
                    });
                }));
            }
            if (pkg.peerDependencies.size > 0 && isVirtual) {
                registerData(`Peer dependencies`, [...pkg.peerDependencies.values()].map(peerDependency => {
                    var _a, _b;
                    const dependency = pkg.dependencies.get(peerDependency.identHash);
                    const resolutionHash = typeof dependency !== `undefined`
                        ? (_a = project.storedResolutions.get(dependency.descriptorHash)) !== null && _a !== void 0 ? _a : null : null;
                    const resolution = resolutionHash !== null
                        ? (_b = project.storedPackages.get(resolutionHash)) !== null && _b !== void 0 ? _b : null : null;
                    return core_1.formatUtils.tuple(core_1.formatUtils.Type.RESOLUTION, {
                        descriptor: peerDependency,
                        locator: resolution,
                    });
                }));
            }
        }
        core_1.treeUtils.emitTree(infoTree, {
            configuration,
            json: this.json,
            stdout: this.context.stdout,
            separators: this.nameOnly ? 0 : 2,
        });
    }
}
InfoCommand.usage = clipanion_1.Command.Usage({
    description: `see information related to packages`,
    details: `
      This command prints various information related to the specified packages, accepting glob patterns.

      By default, if the locator reference is missing, Yarn will default to print the information about all the matching direct dependencies of the package for the active workspace. To instead print all versions of the package that are direct dependencies of any of your workspaces, use the \`-A,--all\` flag. Adding the \`-R,--recursive\` flag will also report transitive dependencies.

      Some fields will be hidden by default in order to keep the output readable, but can be selectively displayed by using additional options (\`--dependents\`, \`--manifest\`, \`--virtuals\`, ...) described in the option descriptions.

      Note that this command will only print the information directly related to the selected packages - if you wish to know why the package is there in the first place, use \`yarn why\` which will do just that (it also provides a \`-R,--recursive\` flag that may be of some help).
    `,
    examples: [[
            `Show information about Lodash`,
            `$0 info lodash`,
        ]],
});
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`-A,--all`, { description: `Print versions of a package from the whole project` })
], InfoCommand.prototype, "all", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`-R,--recursive`, { description: `Print information for all packages, including transitive dependencies` })
], InfoCommand.prototype, "recursive", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Array(`-X,--extra`, { description: `An array of requests of extra data provided by plugins` })
], InfoCommand.prototype, "extra", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`--cache`, { description: `Print information about the cache entry of a package (path, size, checksum)` })
], InfoCommand.prototype, "cache", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`--dependents`, { description: `Print all dependents for each matching package` })
], InfoCommand.prototype, "dependents", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`--manifest`, { description: `Print data obtained by looking at the package archive (license, homepage, ...)` })
], InfoCommand.prototype, "manifest", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`--name-only`, { description: `Only print the name for the matching packages` })
], InfoCommand.prototype, "nameOnly", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`--virtuals`, { description: `Print each instance of the virtual packages` })
], InfoCommand.prototype, "virtuals", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`--json`, { description: `Format the output as an NDJSON stream` })
], InfoCommand.prototype, "json", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Rest()
], InfoCommand.prototype, "patterns", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Path(`info`)
], InfoCommand.prototype, "execute", null);
exports.default = InfoCommand;
