"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const cli_1 = require("@yarnpkg/cli");
const core_1 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const clipanion_1 = require("clipanion");
// eslint-disable-next-line arca/no-default-export
class LinkCommand extends cli_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.all = false;
        this.private = false;
        this.relative = false;
    }
    async execute() {
        const configuration = await core_1.Configuration.find(this.context.cwd, this.context.plugins);
        const { project, workspace } = await core_1.Project.find(configuration, this.context.cwd);
        const cache = await core_1.Cache.find(configuration);
        if (!workspace)
            throw new cli_1.WorkspaceRequiredError(project.cwd, this.context.cwd);
        const absoluteDestination = fslib_1.ppath.resolve(this.context.cwd, fslib_1.npath.toPortablePath(this.destination));
        const configuration2 = await core_1.Configuration.find(absoluteDestination, this.context.plugins);
        const { project: project2, workspace: workspace2 } = await core_1.Project.find(configuration2, absoluteDestination);
        if (!workspace2)
            throw new cli_1.WorkspaceRequiredError(project2.cwd, absoluteDestination);
        const topLevelWorkspace = project.topLevelWorkspace;
        const linkedWorkspaces = [];
        if (this.all) {
            for (const workspace of project2.workspaces)
                if (workspace.manifest.name && (!workspace.manifest.private || this.private))
                    linkedWorkspaces.push(workspace);
            if (linkedWorkspaces.length === 0) {
                throw new clipanion_1.UsageError(`No workspace found to be linked in the target project`);
            }
        }
        else {
            if (!workspace2.manifest.name)
                throw new clipanion_1.UsageError(`The target workspace doesn't have a name and thus cannot be linked`);
            if (workspace2.manifest.private && !this.private)
                throw new clipanion_1.UsageError(`The target workspace is marked private - use the --private flag to link it anyway`);
            linkedWorkspaces.push(workspace2);
        }
        for (const workspace of linkedWorkspaces) {
            const fullName = core_1.structUtils.stringifyIdent(workspace.locator);
            const target = this.relative
                ? fslib_1.ppath.relative(project.cwd, workspace.cwd)
                : workspace.cwd;
            topLevelWorkspace.manifest.resolutions.push({
                pattern: { descriptor: { fullName } },
                reference: `portal:${target}`,
            });
        }
        const report = await core_1.StreamReport.start({
            configuration,
            stdout: this.context.stdout,
        }, async (report) => {
            await project.install({ cache, report });
        });
        return report.exitCode();
    }
}
LinkCommand.usage = clipanion_1.Command.Usage({
    description: `connect the local project to another one`,
    details: `
      This command will set a new \`resolutions\` field in the project-level manifest and point it to the workspace at the specified location (even if part of another project).

      There is no \`yarn unlink\` command. To unlink the workspaces from the current project one must revert the changes made to the \`resolutions\` field.
    `,
    examples: [[
            `Register a remote workspace for use in the current project`,
            `$0 link ~/ts-loader`,
        ], [
            `Register all workspaces from a remote project for use in the current project`,
            `$0 link ~/jest --all`,
        ]],
});
tslib_1.__decorate([
    clipanion_1.Command.String()
], LinkCommand.prototype, "destination", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`-A,--all`, { description: `Link all workspaces belonging to the target project to the current one` })
], LinkCommand.prototype, "all", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`-p,--private`, { description: `Also link private workspaces belonging to the target project to the current one` })
], LinkCommand.prototype, "private", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`-r,--relative`, { description: `Link workspaces using relative paths instead of absolute paths` })
], LinkCommand.prototype, "relative", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Path(`link`)
], LinkCommand.prototype, "execute", null);
exports.default = LinkCommand;
