"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareRepo = exports.runWorkflow = void 0;
const tslib_1 = require("tslib");
const cli_1 = require("@yarnpkg/cli");
const core_1 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const clipanion_1 = require("clipanion");
const os_1 = require("os");
const path_1 = tslib_1.__importDefault(require("path"));
const version_1 = require("../version");
const PR_REGEXP = /^[0-9]+$/;
function getBranchRef(branch) {
    if (PR_REGEXP.test(branch)) {
        return `pull/${branch}/head`;
    }
    else {
        return branch;
    }
}
const cloneWorkflow = ({ repository, branch }, target) => [
    [`git`, `init`, fslib_1.npath.fromPortablePath(target)],
    [`git`, `remote`, `add`, `origin`, repository],
    [`git`, `fetch`, `origin`, getBranchRef(branch)],
    [`git`, `reset`, `--hard`, `FETCH_HEAD`],
];
const updateWorkflow = ({ branch }) => [
    [`git`, `fetch`, `origin`, getBranchRef(branch), `--force`],
    [`git`, `reset`, `--hard`, `FETCH_HEAD`],
    [`git`, `clean`, `-dfx`],
];
const buildWorkflow = ({ plugins, noMinify }, target) => [
    [`yarn`, `build:cli`, ...new Array().concat(...plugins.map(plugin => [`--plugin`, path_1.default.resolve(target, plugin)])), ...noMinify ? [`--no-minify`] : [], `|`],
];
// eslint-disable-next-line arca/no-default-export
class SetVersionSourcesCommand extends cli_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.repository = `https://github.com/yarnpkg/berry.git`;
        this.branch = `master`;
        this.plugins = [];
        this.noMinify = false;
        this.force = false;
    }
    async execute() {
        const configuration = await core_1.Configuration.find(this.context.cwd, this.context.plugins);
        const target = typeof this.installPath !== `undefined`
            ? fslib_1.ppath.resolve(this.context.cwd, fslib_1.npath.toPortablePath(this.installPath))
            : fslib_1.ppath.resolve(fslib_1.npath.toPortablePath(os_1.tmpdir()), `yarnpkg-sources`, core_1.hashUtils.makeHash(this.repository).slice(0, 6));
        const report = await core_1.StreamReport.start({
            configuration,
            stdout: this.context.stdout,
        }, async (report) => {
            await prepareRepo(this, { configuration, report, target });
            report.reportSeparator();
            report.reportInfo(core_1.MessageName.UNNAMED, `Building a fresh bundle`);
            report.reportSeparator();
            await runWorkflow(buildWorkflow(this, target), { configuration, context: this.context, target });
            report.reportSeparator();
            const bundlePath = fslib_1.ppath.resolve(target, `packages/yarnpkg-cli/bundles/yarn.js`);
            const bundleBuffer = await fslib_1.xfs.readFilePromise(bundlePath);
            await version_1.setVersion(configuration, `sources`, bundleBuffer, {
                report,
            });
        });
        return report.exitCode();
    }
}
SetVersionSourcesCommand.usage = clipanion_1.Command.Usage({
    description: `build Yarn from master`,
    details: `
      This command will clone the Yarn repository into a temporary folder, then build it. The resulting bundle will then be copied into the local project.
    `,
    examples: [[
            `Build Yarn from master`,
            `$0 set version from sources`,
        ]],
});
tslib_1.__decorate([
    clipanion_1.Command.String(`--path`, { description: `The path where the repository should be cloned to` })
], SetVersionSourcesCommand.prototype, "installPath", void 0);
tslib_1.__decorate([
    clipanion_1.Command.String(`--repository`, { description: `The repository that should be cloned` })
], SetVersionSourcesCommand.prototype, "repository", void 0);
tslib_1.__decorate([
    clipanion_1.Command.String(`--branch`, { description: `The branch of the repository that should be cloned` })
], SetVersionSourcesCommand.prototype, "branch", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Array(`--plugin`, { description: `An array of additional plugins that should be included in the bundle` })
], SetVersionSourcesCommand.prototype, "plugins", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`--no-minify`, { description: `Build a bundle for development (debugging) - non-minified and non-mangled` })
], SetVersionSourcesCommand.prototype, "noMinify", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`-f,--force`, { description: `Always clone the repository instead of trying to fetch the latest commits` })
], SetVersionSourcesCommand.prototype, "force", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Path(`set`, `version`, `from`, `sources`)
], SetVersionSourcesCommand.prototype, "execute", null);
exports.default = SetVersionSourcesCommand;
async function runWorkflow(workflow, { configuration, context, target }) {
    for (const [fileName, ...args] of workflow) {
        const usePipe = args[args.length - 1] === `|`;
        if (usePipe)
            args.pop();
        if (usePipe) {
            await core_1.execUtils.pipevp(fileName, args, {
                cwd: target,
                stdin: context.stdin,
                stdout: context.stdout,
                stderr: context.stderr,
                strict: true,
            });
        }
        else {
            context.stdout.write(`${core_1.formatUtils.pretty(configuration, `  $ ${[fileName, ...args].join(` `)}`, `grey`)}\n`);
            try {
                await core_1.execUtils.execvp(fileName, args, {
                    cwd: target,
                    strict: true,
                });
            }
            catch (error) {
                context.stdout.write(error.stdout || error.stack);
                throw error;
            }
        }
    }
}
exports.runWorkflow = runWorkflow;
async function prepareRepo(spec, { configuration, report, target }) {
    let ready = false;
    if (!spec.force && fslib_1.xfs.existsSync(fslib_1.ppath.join(target, `.git`))) {
        report.reportInfo(core_1.MessageName.UNNAMED, `Fetching the latest commits`);
        report.reportSeparator();
        try {
            await runWorkflow(updateWorkflow(spec), { configuration, context: spec.context, target });
            ready = true;
        }
        catch (error) {
            report.reportSeparator();
            report.reportWarning(core_1.MessageName.UNNAMED, `Repository update failed; we'll try to regenerate it`);
        }
    }
    if (!ready) {
        report.reportInfo(core_1.MessageName.UNNAMED, `Cloning the remote repository`);
        report.reportSeparator();
        await fslib_1.xfs.removePromise(target);
        await fslib_1.xfs.mkdirPromise(target, { recursive: true });
        await runWorkflow(cloneWorkflow(spec, target), { configuration, context: spec.context, target });
    }
}
exports.prepareRepo = prepareRepo;
