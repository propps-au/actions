"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const cli_1 = require("@yarnpkg/cli");
const core_1 = require("@yarnpkg/core");
const core_2 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const clipanion_1 = require("clipanion");
// eslint-disable-next-line arca/no-default-export
class DlxCommand extends cli_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.quiet = false;
        this.args = [];
    }
    async execute() {
        // Disable telemetry to prevent each `dlx` call from counting as a project
        core_1.Configuration.telemetry = null;
        return await fslib_1.xfs.mktempPromise(async (baseDir) => {
            const tmpDir = fslib_1.ppath.join(baseDir, `dlx-${process.pid}`);
            await fslib_1.xfs.mkdirPromise(tmpDir);
            await fslib_1.xfs.writeFilePromise(fslib_1.ppath.join(tmpDir, `package.json`), `{}\n`);
            await fslib_1.xfs.writeFilePromise(fslib_1.ppath.join(tmpDir, `yarn.lock`), ``);
            const targetYarnrc = fslib_1.ppath.join(tmpDir, `.yarnrc.yml`);
            const projectCwd = await core_1.Configuration.findProjectCwd(this.context.cwd, fslib_1.Filename.lockfile);
            const sourceYarnrc = projectCwd !== null
                ? fslib_1.ppath.join(projectCwd, `.yarnrc.yml`)
                : null;
            if (sourceYarnrc !== null && fslib_1.xfs.existsSync(sourceYarnrc)) {
                await fslib_1.xfs.copyFilePromise(sourceYarnrc, targetYarnrc);
                await core_1.Configuration.updateConfiguration(tmpDir, current => {
                    const nextConfiguration = {
                        ...current,
                        enableGlobalCache: true,
                        enableTelemetry: false,
                    };
                    if (Array.isArray(current.plugins)) {
                        nextConfiguration.plugins = current.plugins.map((plugin) => {
                            const sourcePath = typeof plugin === `string`
                                ? plugin
                                : plugin.path;
                            const remapPath = fslib_1.npath.isAbsolute(sourcePath)
                                ? sourcePath
                                : fslib_1.npath.resolve(fslib_1.npath.fromPortablePath(projectCwd), sourcePath);
                            if (typeof plugin === `string`) {
                                return remapPath;
                            }
                            else {
                                return { path: remapPath, spec: plugin.spec };
                            }
                        });
                    }
                    return nextConfiguration;
                });
            }
            else {
                await fslib_1.xfs.writeFilePromise(targetYarnrc, `enableGlobalCache: true\nenableTelemetry: false\n`);
            }
            const pkgs = typeof this.pkg !== `undefined`
                ? [this.pkg]
                : [this.command];
            const command = core_2.structUtils.parseDescriptor(this.command).name;
            const addExitCode = await this.cli.run([`add`, `--`, ...pkgs], { cwd: tmpDir, quiet: this.quiet });
            if (addExitCode !== 0)
                return addExitCode;
            if (!this.quiet)
                this.context.stdout.write(`\n`);
            const configuration = await core_1.Configuration.find(tmpDir, this.context.plugins);
            const { project, workspace } = await core_1.Project.find(configuration, tmpDir);
            if (workspace === null)
                throw new cli_1.WorkspaceRequiredError(project.cwd, tmpDir);
            await project.restoreInstallState();
            return await core_2.scriptUtils.executeWorkspaceAccessibleBinary(workspace, command, this.args, {
                cwd: this.context.cwd,
                stdin: this.context.stdin,
                stdout: this.context.stdout,
                stderr: this.context.stderr,
            });
        });
    }
}
DlxCommand.usage = clipanion_1.Command.Usage({
    description: `run a package in a temporary environment`,
    details: `
      This command will install a package within a temporary environment, and run its binary script if it contains any. The binary will run within the current cwd.

      By default Yarn will download the package named \`command\`, but this can be changed through the use of the \`-p,--package\` flag which will instruct Yarn to still run the same command but from a different package.

      Using \`yarn dlx\` as a replacement of \`yarn add\` isn't recommended, as it makes your project non-deterministic (Yarn doesn't keep track of the packages installed through \`dlx\` - neither their name, nor their version).
    `,
    examples: [[
            `Use create-react-app to create a new React app`,
            `yarn dlx create-react-app ./my-app`,
        ]],
});
tslib_1.__decorate([
    clipanion_1.Command.String(`-p,--package`, { description: `The package to run the provided command from` })
], DlxCommand.prototype, "pkg", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`-q,--quiet`, { description: `Only report critical errors instead of printing the full install logs` })
], DlxCommand.prototype, "quiet", void 0);
tslib_1.__decorate([
    clipanion_1.Command.String()
], DlxCommand.prototype, "command", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Proxy()
], DlxCommand.prototype, "args", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Path(`dlx`)
], DlxCommand.prototype, "execute", null);
exports.default = DlxCommand;
